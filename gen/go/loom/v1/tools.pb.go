// Copyright 2026 Teradata
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        (unknown)
// source: loom/v1/tools.proto

package loomv1

import (
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"

	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// SearchMode controls the accuracy vs speed tradeoff for tool search.
type SearchMode int32

const (
	// UNSPECIFIED defaults to BALANCED.
	SearchMode_SEARCH_MODE_UNSPECIFIED SearchMode = 0
	// FAST uses FTS5 only - fastest but least accurate for ambiguous queries.
	SearchMode_SEARCH_MODE_FAST SearchMode = 1
	// BALANCED uses FTS5 + LLM re-ranking - good balance (default).
	SearchMode_SEARCH_MODE_BALANCED SearchMode = 2
	// ACCURATE uses full LLM pipeline with query understanding - most accurate.
	SearchMode_SEARCH_MODE_ACCURATE SearchMode = 3
)

// Enum value maps for SearchMode.
var (
	SearchMode_name = map[int32]string{
		0: "SEARCH_MODE_UNSPECIFIED",
		1: "SEARCH_MODE_FAST",
		2: "SEARCH_MODE_BALANCED",
		3: "SEARCH_MODE_ACCURATE",
	}
	SearchMode_value = map[string]int32{
		"SEARCH_MODE_UNSPECIFIED": 0,
		"SEARCH_MODE_FAST":        1,
		"SEARCH_MODE_BALANCED":    2,
		"SEARCH_MODE_ACCURATE":    3,
	}
)

func (x SearchMode) Enum() *SearchMode {
	p := new(SearchMode)
	*p = x
	return p
}

func (x SearchMode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (SearchMode) Descriptor() protoreflect.EnumDescriptor {
	return file_loom_v1_tools_proto_enumTypes[0].Descriptor()
}

func (SearchMode) Type() protoreflect.EnumType {
	return &file_loom_v1_tools_proto_enumTypes[0]
}

func (x SearchMode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use SearchMode.Descriptor instead.
func (SearchMode) EnumDescriptor() ([]byte, []int) {
	return file_loom_v1_tools_proto_rawDescGZIP(), []int{0}
}

// ToolSource identifies where a tool comes from.
type ToolSource int32

const (
	ToolSource_TOOL_SOURCE_UNSPECIFIED ToolSource = 0
	ToolSource_TOOL_SOURCE_BUILTIN     ToolSource = 1 // Built into Loom (pkg/shuttle)
	ToolSource_TOOL_SOURCE_MCP         ToolSource = 2 // From an MCP server
	ToolSource_TOOL_SOURCE_CUSTOM      ToolSource = 3 // Custom tool definition
)

// Enum value maps for ToolSource.
var (
	ToolSource_name = map[int32]string{
		0: "TOOL_SOURCE_UNSPECIFIED",
		1: "TOOL_SOURCE_BUILTIN",
		2: "TOOL_SOURCE_MCP",
		3: "TOOL_SOURCE_CUSTOM",
	}
	ToolSource_value = map[string]int32{
		"TOOL_SOURCE_UNSPECIFIED": 0,
		"TOOL_SOURCE_BUILTIN":     1,
		"TOOL_SOURCE_MCP":         2,
		"TOOL_SOURCE_CUSTOM":      3,
	}
)

func (x ToolSource) Enum() *ToolSource {
	p := new(ToolSource)
	*p = x
	return p
}

func (x ToolSource) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ToolSource) Descriptor() protoreflect.EnumDescriptor {
	return file_loom_v1_tools_proto_enumTypes[1].Descriptor()
}

func (ToolSource) Type() protoreflect.EnumType {
	return &file_loom_v1_tools_proto_enumTypes[1]
}

func (x ToolSource) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ToolSource.Descriptor instead.
func (ToolSource) EnumDescriptor() ([]byte, []int) {
	return file_loom_v1_tools_proto_rawDescGZIP(), []int{1}
}

// SearchToolsRequest is the input for tool search.
type SearchToolsRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Natural language query describing what the agent needs.
	// Examples:
	//
	//	"send a slack notification"
	//	"query a postgres database"
	//	"read and parse a JSON file"
	Query string `protobuf:"bytes,1,opt,name=query,proto3" json:"query,omitempty"`
	// Search mode controlling accuracy vs speed.
	Mode SearchMode `protobuf:"varint,2,opt,name=mode,proto3,enum=loom.v1.SearchMode" json:"mode,omitempty"`
	// Optional capability filters to narrow results.
	// Examples: ["notification", "database", "file_io"]
	CapabilityFilters []string `protobuf:"bytes,3,rep,name=capability_filters,json=capabilityFilters,proto3" json:"capability_filters,omitempty"`
	// Optional source filter to limit to specific sources.
	SourceFilters []ToolSource `protobuf:"varint,4,rep,packed,name=source_filters,json=sourceFilters,proto3,enum=loom.v1.ToolSource" json:"source_filters,omitempty"`
	// Maximum number of results to return (default: 5, max: 20).
	MaxResults int32 `protobuf:"varint,5,opt,name=max_results,json=maxResults,proto3" json:"max_results,omitempty"`
	// Include full JSON schema in results (default: true).
	IncludeSchema bool `protobuf:"varint,6,opt,name=include_schema,json=includeSchema,proto3" json:"include_schema,omitempty"`
	// Context about the agent's current task (helps LLM rank better).
	TaskContext   string `protobuf:"bytes,7,opt,name=task_context,json=taskContext,proto3" json:"task_context,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SearchToolsRequest) Reset() {
	*x = SearchToolsRequest{}
	mi := &file_loom_v1_tools_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SearchToolsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SearchToolsRequest) ProtoMessage() {}

func (x *SearchToolsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_loom_v1_tools_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SearchToolsRequest.ProtoReflect.Descriptor instead.
func (*SearchToolsRequest) Descriptor() ([]byte, []int) {
	return file_loom_v1_tools_proto_rawDescGZIP(), []int{0}
}

func (x *SearchToolsRequest) GetQuery() string {
	if x != nil {
		return x.Query
	}
	return ""
}

func (x *SearchToolsRequest) GetMode() SearchMode {
	if x != nil {
		return x.Mode
	}
	return SearchMode_SEARCH_MODE_UNSPECIFIED
}

func (x *SearchToolsRequest) GetCapabilityFilters() []string {
	if x != nil {
		return x.CapabilityFilters
	}
	return nil
}

func (x *SearchToolsRequest) GetSourceFilters() []ToolSource {
	if x != nil {
		return x.SourceFilters
	}
	return nil
}

func (x *SearchToolsRequest) GetMaxResults() int32 {
	if x != nil {
		return x.MaxResults
	}
	return 0
}

func (x *SearchToolsRequest) GetIncludeSchema() bool {
	if x != nil {
		return x.IncludeSchema
	}
	return false
}

func (x *SearchToolsRequest) GetTaskContext() string {
	if x != nil {
		return x.TaskContext
	}
	return ""
}

// SearchToolsResponse contains the search results.
type SearchToolsResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Matched tools ordered by relevance.
	Results []*ToolSearchResult `protobuf:"bytes,1,rep,name=results,proto3" json:"results,omitempty"`
	// Search metadata for debugging/observability.
	Metadata      *SearchMetadata `protobuf:"bytes,2,opt,name=metadata,proto3" json:"metadata,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SearchToolsResponse) Reset() {
	*x = SearchToolsResponse{}
	mi := &file_loom_v1_tools_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SearchToolsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SearchToolsResponse) ProtoMessage() {}

func (x *SearchToolsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_loom_v1_tools_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SearchToolsResponse.ProtoReflect.Descriptor instead.
func (*SearchToolsResponse) Descriptor() ([]byte, []int) {
	return file_loom_v1_tools_proto_rawDescGZIP(), []int{1}
}

func (x *SearchToolsResponse) GetResults() []*ToolSearchResult {
	if x != nil {
		return x.Results
	}
	return nil
}

func (x *SearchToolsResponse) GetMetadata() *SearchMetadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

// ToolSearchResult is a single search result with confidence scoring.
type ToolSearchResult struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The indexed tool definition.
	Tool *IndexedTool `protobuf:"bytes,1,opt,name=tool,proto3" json:"tool,omitempty"`
	// Confidence score (0.0 - 1.0) indicating match quality.
	Confidence float64 `protobuf:"fixed64,2,opt,name=confidence,proto3" json:"confidence,omitempty"`
	// Explanation of why this tool matched (from LLM re-ranking).
	MatchReason string `protobuf:"bytes,3,opt,name=match_reason,json=matchReason,proto3" json:"match_reason,omitempty"`
	// Relevance signals that contributed to the score.
	Signals       []*RelevanceSignal `protobuf:"bytes,4,rep,name=signals,proto3" json:"signals,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ToolSearchResult) Reset() {
	*x = ToolSearchResult{}
	mi := &file_loom_v1_tools_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ToolSearchResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ToolSearchResult) ProtoMessage() {}

func (x *ToolSearchResult) ProtoReflect() protoreflect.Message {
	mi := &file_loom_v1_tools_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ToolSearchResult.ProtoReflect.Descriptor instead.
func (*ToolSearchResult) Descriptor() ([]byte, []int) {
	return file_loom_v1_tools_proto_rawDescGZIP(), []int{2}
}

func (x *ToolSearchResult) GetTool() *IndexedTool {
	if x != nil {
		return x.Tool
	}
	return nil
}

func (x *ToolSearchResult) GetConfidence() float64 {
	if x != nil {
		return x.Confidence
	}
	return 0
}

func (x *ToolSearchResult) GetMatchReason() string {
	if x != nil {
		return x.MatchReason
	}
	return ""
}

func (x *ToolSearchResult) GetSignals() []*RelevanceSignal {
	if x != nil {
		return x.Signals
	}
	return nil
}

// RelevanceSignal explains why a tool was ranked highly.
type RelevanceSignal struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	SignalType    string                 `protobuf:"bytes,1,opt,name=signal_type,json=signalType,proto3" json:"signal_type,omitempty"` // "keyword_match", "capability_match", "semantic_similarity"
	Description   string                 `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	Weight        float64                `protobuf:"fixed64,3,opt,name=weight,proto3" json:"weight,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RelevanceSignal) Reset() {
	*x = RelevanceSignal{}
	mi := &file_loom_v1_tools_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RelevanceSignal) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RelevanceSignal) ProtoMessage() {}

func (x *RelevanceSignal) ProtoReflect() protoreflect.Message {
	mi := &file_loom_v1_tools_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RelevanceSignal.ProtoReflect.Descriptor instead.
func (*RelevanceSignal) Descriptor() ([]byte, []int) {
	return file_loom_v1_tools_proto_rawDescGZIP(), []int{3}
}

func (x *RelevanceSignal) GetSignalType() string {
	if x != nil {
		return x.SignalType
	}
	return ""
}

func (x *RelevanceSignal) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *RelevanceSignal) GetWeight() float64 {
	if x != nil {
		return x.Weight
	}
	return 0
}

// SearchMetadata provides debugging info about the search.
type SearchMetadata struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Total tools in the index.
	TotalIndexed int32 `protobuf:"varint,1,opt,name=total_indexed,json=totalIndexed,proto3" json:"total_indexed,omitempty"`
	// Number of candidates after FTS5 retrieval.
	CandidatesRetrieved int32 `protobuf:"varint,2,opt,name=candidates_retrieved,json=candidatesRetrieved,proto3" json:"candidates_retrieved,omitempty"`
	// Search mode that was used.
	ModeUsed SearchMode `protobuf:"varint,3,opt,name=mode_used,json=modeUsed,proto3,enum=loom.v1.SearchMode" json:"mode_used,omitempty"`
	// Time taken for each stage (milliseconds).
	QueryUnderstandingMs int64 `protobuf:"varint,4,opt,name=query_understanding_ms,json=queryUnderstandingMs,proto3" json:"query_understanding_ms,omitempty"`
	FtsRetrievalMs       int64 `protobuf:"varint,5,opt,name=fts_retrieval_ms,json=ftsRetrievalMs,proto3" json:"fts_retrieval_ms,omitempty"`
	LlmRerankingMs       int64 `protobuf:"varint,6,opt,name=llm_reranking_ms,json=llmRerankingMs,proto3" json:"llm_reranking_ms,omitempty"`
	TotalMs              int64 `protobuf:"varint,7,opt,name=total_ms,json=totalMs,proto3" json:"total_ms,omitempty"`
	// Expanded search terms (from LLM query understanding).
	ExpandedTerms []string `protobuf:"bytes,8,rep,name=expanded_terms,json=expandedTerms,proto3" json:"expanded_terms,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SearchMetadata) Reset() {
	*x = SearchMetadata{}
	mi := &file_loom_v1_tools_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SearchMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SearchMetadata) ProtoMessage() {}

func (x *SearchMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_loom_v1_tools_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SearchMetadata.ProtoReflect.Descriptor instead.
func (*SearchMetadata) Descriptor() ([]byte, []int) {
	return file_loom_v1_tools_proto_rawDescGZIP(), []int{4}
}

func (x *SearchMetadata) GetTotalIndexed() int32 {
	if x != nil {
		return x.TotalIndexed
	}
	return 0
}

func (x *SearchMetadata) GetCandidatesRetrieved() int32 {
	if x != nil {
		return x.CandidatesRetrieved
	}
	return 0
}

func (x *SearchMetadata) GetModeUsed() SearchMode {
	if x != nil {
		return x.ModeUsed
	}
	return SearchMode_SEARCH_MODE_UNSPECIFIED
}

func (x *SearchMetadata) GetQueryUnderstandingMs() int64 {
	if x != nil {
		return x.QueryUnderstandingMs
	}
	return 0
}

func (x *SearchMetadata) GetFtsRetrievalMs() int64 {
	if x != nil {
		return x.FtsRetrievalMs
	}
	return 0
}

func (x *SearchMetadata) GetLlmRerankingMs() int64 {
	if x != nil {
		return x.LlmRerankingMs
	}
	return 0
}

func (x *SearchMetadata) GetTotalMs() int64 {
	if x != nil {
		return x.TotalMs
	}
	return 0
}

func (x *SearchMetadata) GetExpandedTerms() []string {
	if x != nil {
		return x.ExpandedTerms
	}
	return nil
}

// IndexedTool is the complete indexed definition of a tool for search.
// Extends the basic ToolDefinition with search-specific metadata.
type IndexedTool struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Unique identifier for this tool (source:server:name format).
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Human-readable name.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// Detailed description of what the tool does.
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// Source of the tool.
	Source ToolSource `protobuf:"varint,4,opt,name=source,proto3,enum=loom.v1.ToolSource" json:"source,omitempty"`
	// For MCP tools, which server provides it.
	McpServer string `protobuf:"bytes,5,opt,name=mcp_server,json=mcpServer,proto3" json:"mcp_server,omitempty"`
	// JSON Schema for the tool's input parameters.
	InputSchema string `protobuf:"bytes,6,opt,name=input_schema,json=inputSchema,proto3" json:"input_schema,omitempty"`
	// JSON Schema for the tool's output (if known).
	OutputSchema string `protobuf:"bytes,7,opt,name=output_schema,json=outputSchema,proto3" json:"output_schema,omitempty"`
	// Capability tags for filtering.
	Capabilities []string `protobuf:"bytes,8,rep,name=capabilities,proto3" json:"capabilities,omitempty"`
	// Keywords for search (auto-extracted + manual).
	Keywords []string `protobuf:"bytes,9,rep,name=keywords,proto3" json:"keywords,omitempty"`
	// Usage examples (optional, improves search accuracy).
	Examples []*ToolExample `protobuf:"bytes,10,rep,name=examples,proto3" json:"examples,omitempty"`
	// When this tool was last indexed.
	IndexedAt string `protobuf:"bytes,11,opt,name=indexed_at,json=indexedAt,proto3" json:"indexed_at,omitempty"`
	// Version info (for MCP tools, from server).
	Version string `protobuf:"bytes,12,opt,name=version,proto3" json:"version,omitempty"`
	// Whether this tool requires special permissions.
	RequiresApproval bool `protobuf:"varint,13,opt,name=requires_approval,json=requiresApproval,proto3" json:"requires_approval,omitempty"`
	// Rate limit info (if any).
	RateLimit     *RateLimitInfo `protobuf:"bytes,14,opt,name=rate_limit,json=rateLimit,proto3" json:"rate_limit,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IndexedTool) Reset() {
	*x = IndexedTool{}
	mi := &file_loom_v1_tools_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IndexedTool) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IndexedTool) ProtoMessage() {}

func (x *IndexedTool) ProtoReflect() protoreflect.Message {
	mi := &file_loom_v1_tools_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IndexedTool.ProtoReflect.Descriptor instead.
func (*IndexedTool) Descriptor() ([]byte, []int) {
	return file_loom_v1_tools_proto_rawDescGZIP(), []int{5}
}

func (x *IndexedTool) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *IndexedTool) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *IndexedTool) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *IndexedTool) GetSource() ToolSource {
	if x != nil {
		return x.Source
	}
	return ToolSource_TOOL_SOURCE_UNSPECIFIED
}

func (x *IndexedTool) GetMcpServer() string {
	if x != nil {
		return x.McpServer
	}
	return ""
}

func (x *IndexedTool) GetInputSchema() string {
	if x != nil {
		return x.InputSchema
	}
	return ""
}

func (x *IndexedTool) GetOutputSchema() string {
	if x != nil {
		return x.OutputSchema
	}
	return ""
}

func (x *IndexedTool) GetCapabilities() []string {
	if x != nil {
		return x.Capabilities
	}
	return nil
}

func (x *IndexedTool) GetKeywords() []string {
	if x != nil {
		return x.Keywords
	}
	return nil
}

func (x *IndexedTool) GetExamples() []*ToolExample {
	if x != nil {
		return x.Examples
	}
	return nil
}

func (x *IndexedTool) GetIndexedAt() string {
	if x != nil {
		return x.IndexedAt
	}
	return ""
}

func (x *IndexedTool) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *IndexedTool) GetRequiresApproval() bool {
	if x != nil {
		return x.RequiresApproval
	}
	return false
}

func (x *IndexedTool) GetRateLimit() *RateLimitInfo {
	if x != nil {
		return x.RateLimit
	}
	return nil
}

// ToolExample shows how to use a tool.
type ToolExample struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Natural language description of the use case.
	Description string `protobuf:"bytes,1,opt,name=description,proto3" json:"description,omitempty"`
	// Example input (JSON).
	Input string `protobuf:"bytes,2,opt,name=input,proto3" json:"input,omitempty"`
	// Example output (JSON).
	Output        string `protobuf:"bytes,3,opt,name=output,proto3" json:"output,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ToolExample) Reset() {
	*x = ToolExample{}
	mi := &file_loom_v1_tools_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ToolExample) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ToolExample) ProtoMessage() {}

func (x *ToolExample) ProtoReflect() protoreflect.Message {
	mi := &file_loom_v1_tools_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ToolExample.ProtoReflect.Descriptor instead.
func (*ToolExample) Descriptor() ([]byte, []int) {
	return file_loom_v1_tools_proto_rawDescGZIP(), []int{6}
}

func (x *ToolExample) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *ToolExample) GetInput() string {
	if x != nil {
		return x.Input
	}
	return ""
}

func (x *ToolExample) GetOutput() string {
	if x != nil {
		return x.Output
	}
	return ""
}

// RateLimitInfo describes rate limiting for a tool.
type RateLimitInfo struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	RequestsPerMinute int32                  `protobuf:"varint,1,opt,name=requests_per_minute,json=requestsPerMinute,proto3" json:"requests_per_minute,omitempty"`
	RequestsPerHour   int32                  `protobuf:"varint,2,opt,name=requests_per_hour,json=requestsPerHour,proto3" json:"requests_per_hour,omitempty"`
	Notes             string                 `protobuf:"bytes,3,opt,name=notes,proto3" json:"notes,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *RateLimitInfo) Reset() {
	*x = RateLimitInfo{}
	mi := &file_loom_v1_tools_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RateLimitInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RateLimitInfo) ProtoMessage() {}

func (x *RateLimitInfo) ProtoReflect() protoreflect.Message {
	mi := &file_loom_v1_tools_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RateLimitInfo.ProtoReflect.Descriptor instead.
func (*RateLimitInfo) Descriptor() ([]byte, []int) {
	return file_loom_v1_tools_proto_rawDescGZIP(), []int{7}
}

func (x *RateLimitInfo) GetRequestsPerMinute() int32 {
	if x != nil {
		return x.RequestsPerMinute
	}
	return 0
}

func (x *RateLimitInfo) GetRequestsPerHour() int32 {
	if x != nil {
		return x.RequestsPerHour
	}
	return 0
}

func (x *RateLimitInfo) GetNotes() string {
	if x != nil {
		return x.Notes
	}
	return ""
}

// IndexToolsRequest triggers tool re-indexing.
type IndexToolsRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// If true, full re-index. If false, incremental update.
	FullReindex bool `protobuf:"varint,1,opt,name=full_reindex,json=fullReindex,proto3" json:"full_reindex,omitempty"`
	// Specific sources to re-index (empty = all).
	Sources []ToolSource `protobuf:"varint,2,rep,packed,name=sources,proto3,enum=loom.v1.ToolSource" json:"sources,omitempty"`
	// Specific MCP servers to re-index (empty = all).
	McpServers    []string `protobuf:"bytes,3,rep,name=mcp_servers,json=mcpServers,proto3" json:"mcp_servers,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IndexToolsRequest) Reset() {
	*x = IndexToolsRequest{}
	mi := &file_loom_v1_tools_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IndexToolsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IndexToolsRequest) ProtoMessage() {}

func (x *IndexToolsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_loom_v1_tools_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IndexToolsRequest.ProtoReflect.Descriptor instead.
func (*IndexToolsRequest) Descriptor() ([]byte, []int) {
	return file_loom_v1_tools_proto_rawDescGZIP(), []int{8}
}

func (x *IndexToolsRequest) GetFullReindex() bool {
	if x != nil {
		return x.FullReindex
	}
	return false
}

func (x *IndexToolsRequest) GetSources() []ToolSource {
	if x != nil {
		return x.Sources
	}
	return nil
}

func (x *IndexToolsRequest) GetMcpServers() []string {
	if x != nil {
		return x.McpServers
	}
	return nil
}

// IndexToolsResponse returns indexing results.
type IndexToolsResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Number of tools indexed by source.
	BuiltinCount int32 `protobuf:"varint,1,opt,name=builtin_count,json=builtinCount,proto3" json:"builtin_count,omitempty"`
	McpCount     int32 `protobuf:"varint,2,opt,name=mcp_count,json=mcpCount,proto3" json:"mcp_count,omitempty"`
	CustomCount  int32 `protobuf:"varint,3,opt,name=custom_count,json=customCount,proto3" json:"custom_count,omitempty"`
	TotalCount   int32 `protobuf:"varint,4,opt,name=total_count,json=totalCount,proto3" json:"total_count,omitempty"`
	// Any errors during indexing.
	Errors []*IndexError `protobuf:"bytes,5,rep,name=errors,proto3" json:"errors,omitempty"`
	// Time taken (milliseconds).
	DurationMs    int64 `protobuf:"varint,6,opt,name=duration_ms,json=durationMs,proto3" json:"duration_ms,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IndexToolsResponse) Reset() {
	*x = IndexToolsResponse{}
	mi := &file_loom_v1_tools_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IndexToolsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IndexToolsResponse) ProtoMessage() {}

func (x *IndexToolsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_loom_v1_tools_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IndexToolsResponse.ProtoReflect.Descriptor instead.
func (*IndexToolsResponse) Descriptor() ([]byte, []int) {
	return file_loom_v1_tools_proto_rawDescGZIP(), []int{9}
}

func (x *IndexToolsResponse) GetBuiltinCount() int32 {
	if x != nil {
		return x.BuiltinCount
	}
	return 0
}

func (x *IndexToolsResponse) GetMcpCount() int32 {
	if x != nil {
		return x.McpCount
	}
	return 0
}

func (x *IndexToolsResponse) GetCustomCount() int32 {
	if x != nil {
		return x.CustomCount
	}
	return 0
}

func (x *IndexToolsResponse) GetTotalCount() int32 {
	if x != nil {
		return x.TotalCount
	}
	return 0
}

func (x *IndexToolsResponse) GetErrors() []*IndexError {
	if x != nil {
		return x.Errors
	}
	return nil
}

func (x *IndexToolsResponse) GetDurationMs() int64 {
	if x != nil {
		return x.DurationMs
	}
	return 0
}

// IndexError describes a failure during indexing.
type IndexError struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Source        ToolSource             `protobuf:"varint,1,opt,name=source,proto3,enum=loom.v1.ToolSource" json:"source,omitempty"`
	ServerName    string                 `protobuf:"bytes,2,opt,name=server_name,json=serverName,proto3" json:"server_name,omitempty"` // For MCP errors
	ErrorMessage  string                 `protobuf:"bytes,3,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IndexError) Reset() {
	*x = IndexError{}
	mi := &file_loom_v1_tools_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IndexError) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IndexError) ProtoMessage() {}

func (x *IndexError) ProtoReflect() protoreflect.Message {
	mi := &file_loom_v1_tools_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IndexError.ProtoReflect.Descriptor instead.
func (*IndexError) Descriptor() ([]byte, []int) {
	return file_loom_v1_tools_proto_rawDescGZIP(), []int{10}
}

func (x *IndexError) GetSource() ToolSource {
	if x != nil {
		return x.Source
	}
	return ToolSource_TOOL_SOURCE_UNSPECIFIED
}

func (x *IndexError) GetServerName() string {
	if x != nil {
		return x.ServerName
	}
	return ""
}

func (x *IndexError) GetErrorMessage() string {
	if x != nil {
		return x.ErrorMessage
	}
	return ""
}

// ListToolSourcesRequest lists all tool sources.
type ListToolSourcesRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListToolSourcesRequest) Reset() {
	*x = ListToolSourcesRequest{}
	mi := &file_loom_v1_tools_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListToolSourcesRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListToolSourcesRequest) ProtoMessage() {}

func (x *ListToolSourcesRequest) ProtoReflect() protoreflect.Message {
	mi := &file_loom_v1_tools_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListToolSourcesRequest.ProtoReflect.Descriptor instead.
func (*ListToolSourcesRequest) Descriptor() ([]byte, []int) {
	return file_loom_v1_tools_proto_rawDescGZIP(), []int{11}
}

// ListToolSourcesResponse returns registered sources.
type ListToolSourcesResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Sources       []*ToolSourceInfo      `protobuf:"bytes,1,rep,name=sources,proto3" json:"sources,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListToolSourcesResponse) Reset() {
	*x = ListToolSourcesResponse{}
	mi := &file_loom_v1_tools_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListToolSourcesResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListToolSourcesResponse) ProtoMessage() {}

func (x *ListToolSourcesResponse) ProtoReflect() protoreflect.Message {
	mi := &file_loom_v1_tools_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListToolSourcesResponse.ProtoReflect.Descriptor instead.
func (*ListToolSourcesResponse) Descriptor() ([]byte, []int) {
	return file_loom_v1_tools_proto_rawDescGZIP(), []int{12}
}

func (x *ListToolSourcesResponse) GetSources() []*ToolSourceInfo {
	if x != nil {
		return x.Sources
	}
	return nil
}

// ToolSourceInfo describes a tool source.
type ToolSourceInfo struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Type          ToolSource             `protobuf:"varint,1,opt,name=type,proto3,enum=loom.v1.ToolSource" json:"type,omitempty"`
	Name          string                 `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"` // e.g., "slack-mcp", "builtin"
	Description   string                 `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	ToolCount     int32                  `protobuf:"varint,4,opt,name=tool_count,json=toolCount,proto3" json:"tool_count,omitempty"`
	LastIndexed   string                 `protobuf:"bytes,5,opt,name=last_indexed,json=lastIndexed,proto3" json:"last_indexed,omitempty"`
	Available     bool                   `protobuf:"varint,6,opt,name=available,proto3" json:"available,omitempty"`                             // Is the source currently reachable?
	StatusMessage string                 `protobuf:"bytes,7,opt,name=status_message,json=statusMessage,proto3" json:"status_message,omitempty"` // e.g., "connected", "connection failed"
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ToolSourceInfo) Reset() {
	*x = ToolSourceInfo{}
	mi := &file_loom_v1_tools_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ToolSourceInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ToolSourceInfo) ProtoMessage() {}

func (x *ToolSourceInfo) ProtoReflect() protoreflect.Message {
	mi := &file_loom_v1_tools_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ToolSourceInfo.ProtoReflect.Descriptor instead.
func (*ToolSourceInfo) Descriptor() ([]byte, []int) {
	return file_loom_v1_tools_proto_rawDescGZIP(), []int{13}
}

func (x *ToolSourceInfo) GetType() ToolSource {
	if x != nil {
		return x.Type
	}
	return ToolSource_TOOL_SOURCE_UNSPECIFIED
}

func (x *ToolSourceInfo) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *ToolSourceInfo) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *ToolSourceInfo) GetToolCount() int32 {
	if x != nil {
		return x.ToolCount
	}
	return 0
}

func (x *ToolSourceInfo) GetLastIndexed() string {
	if x != nil {
		return x.LastIndexed
	}
	return ""
}

func (x *ToolSourceInfo) GetAvailable() bool {
	if x != nil {
		return x.Available
	}
	return false
}

func (x *ToolSourceInfo) GetStatusMessage() string {
	if x != nil {
		return x.StatusMessage
	}
	return ""
}

// GetIndexedToolRequest retrieves a specific tool.
type GetIndexedToolRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Tool ID or name.
	ToolId string `protobuf:"bytes,1,opt,name=tool_id,json=toolId,proto3" json:"tool_id,omitempty"`
	// If tool_id is ambiguous, specify source.
	Source        ToolSource `protobuf:"varint,2,opt,name=source,proto3,enum=loom.v1.ToolSource" json:"source,omitempty"`
	McpServer     string     `protobuf:"bytes,3,opt,name=mcp_server,json=mcpServer,proto3" json:"mcp_server,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetIndexedToolRequest) Reset() {
	*x = GetIndexedToolRequest{}
	mi := &file_loom_v1_tools_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetIndexedToolRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetIndexedToolRequest) ProtoMessage() {}

func (x *GetIndexedToolRequest) ProtoReflect() protoreflect.Message {
	mi := &file_loom_v1_tools_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetIndexedToolRequest.ProtoReflect.Descriptor instead.
func (*GetIndexedToolRequest) Descriptor() ([]byte, []int) {
	return file_loom_v1_tools_proto_rawDescGZIP(), []int{14}
}

func (x *GetIndexedToolRequest) GetToolId() string {
	if x != nil {
		return x.ToolId
	}
	return ""
}

func (x *GetIndexedToolRequest) GetSource() ToolSource {
	if x != nil {
		return x.Source
	}
	return ToolSource_TOOL_SOURCE_UNSPECIFIED
}

func (x *GetIndexedToolRequest) GetMcpServer() string {
	if x != nil {
		return x.McpServer
	}
	return ""
}

// GetToolsByCapabilityRequest finds tools by capability tag.
type GetToolsByCapabilityRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Capability to search for.
	Capability string `protobuf:"bytes,1,opt,name=capability,proto3" json:"capability,omitempty"`
	// Optional source filter.
	SourceFilters []ToolSource `protobuf:"varint,2,rep,packed,name=source_filters,json=sourceFilters,proto3,enum=loom.v1.ToolSource" json:"source_filters,omitempty"`
	// Max results (default: 10).
	MaxResults    int32 `protobuf:"varint,3,opt,name=max_results,json=maxResults,proto3" json:"max_results,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetToolsByCapabilityRequest) Reset() {
	*x = GetToolsByCapabilityRequest{}
	mi := &file_loom_v1_tools_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetToolsByCapabilityRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetToolsByCapabilityRequest) ProtoMessage() {}

func (x *GetToolsByCapabilityRequest) ProtoReflect() protoreflect.Message {
	mi := &file_loom_v1_tools_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetToolsByCapabilityRequest.ProtoReflect.Descriptor instead.
func (*GetToolsByCapabilityRequest) Descriptor() ([]byte, []int) {
	return file_loom_v1_tools_proto_rawDescGZIP(), []int{15}
}

func (x *GetToolsByCapabilityRequest) GetCapability() string {
	if x != nil {
		return x.Capability
	}
	return ""
}

func (x *GetToolsByCapabilityRequest) GetSourceFilters() []ToolSource {
	if x != nil {
		return x.SourceFilters
	}
	return nil
}

func (x *GetToolsByCapabilityRequest) GetMaxResults() int32 {
	if x != nil {
		return x.MaxResults
	}
	return 0
}

// GetToolsByCapabilityResponse returns matching tools.
type GetToolsByCapabilityResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Tools         []*IndexedTool         `protobuf:"bytes,1,rep,name=tools,proto3" json:"tools,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetToolsByCapabilityResponse) Reset() {
	*x = GetToolsByCapabilityResponse{}
	mi := &file_loom_v1_tools_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetToolsByCapabilityResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetToolsByCapabilityResponse) ProtoMessage() {}

func (x *GetToolsByCapabilityResponse) ProtoReflect() protoreflect.Message {
	mi := &file_loom_v1_tools_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetToolsByCapabilityResponse.ProtoReflect.Descriptor instead.
func (*GetToolsByCapabilityResponse) Descriptor() ([]byte, []int) {
	return file_loom_v1_tools_proto_rawDescGZIP(), []int{16}
}

func (x *GetToolsByCapabilityResponse) GetTools() []*IndexedTool {
	if x != nil {
		return x.Tools
	}
	return nil
}

var File_loom_v1_tools_proto protoreflect.FileDescriptor

const file_loom_v1_tools_proto_rawDesc = "" +
	"\n" +
	"\x13loom/v1/tools.proto\x12\aloom.v1\"\xa9\x02\n" +
	"\x12SearchToolsRequest\x12\x14\n" +
	"\x05query\x18\x01 \x01(\tR\x05query\x12'\n" +
	"\x04mode\x18\x02 \x01(\x0e2\x13.loom.v1.SearchModeR\x04mode\x12-\n" +
	"\x12capability_filters\x18\x03 \x03(\tR\x11capabilityFilters\x12:\n" +
	"\x0esource_filters\x18\x04 \x03(\x0e2\x13.loom.v1.ToolSourceR\rsourceFilters\x12\x1f\n" +
	"\vmax_results\x18\x05 \x01(\x05R\n" +
	"maxResults\x12%\n" +
	"\x0einclude_schema\x18\x06 \x01(\bR\rincludeSchema\x12!\n" +
	"\ftask_context\x18\a \x01(\tR\vtaskContext\"\x7f\n" +
	"\x13SearchToolsResponse\x123\n" +
	"\aresults\x18\x01 \x03(\v2\x19.loom.v1.ToolSearchResultR\aresults\x123\n" +
	"\bmetadata\x18\x02 \x01(\v2\x17.loom.v1.SearchMetadataR\bmetadata\"\xb3\x01\n" +
	"\x10ToolSearchResult\x12(\n" +
	"\x04tool\x18\x01 \x01(\v2\x14.loom.v1.IndexedToolR\x04tool\x12\x1e\n" +
	"\n" +
	"confidence\x18\x02 \x01(\x01R\n" +
	"confidence\x12!\n" +
	"\fmatch_reason\x18\x03 \x01(\tR\vmatchReason\x122\n" +
	"\asignals\x18\x04 \x03(\v2\x18.loom.v1.RelevanceSignalR\asignals\"l\n" +
	"\x0fRelevanceSignal\x12\x1f\n" +
	"\vsignal_type\x18\x01 \x01(\tR\n" +
	"signalType\x12 \n" +
	"\vdescription\x18\x02 \x01(\tR\vdescription\x12\x16\n" +
	"\x06weight\x18\x03 \x01(\x01R\x06weight\"\xe6\x02\n" +
	"\x0eSearchMetadata\x12#\n" +
	"\rtotal_indexed\x18\x01 \x01(\x05R\ftotalIndexed\x121\n" +
	"\x14candidates_retrieved\x18\x02 \x01(\x05R\x13candidatesRetrieved\x120\n" +
	"\tmode_used\x18\x03 \x01(\x0e2\x13.loom.v1.SearchModeR\bmodeUsed\x124\n" +
	"\x16query_understanding_ms\x18\x04 \x01(\x03R\x14queryUnderstandingMs\x12(\n" +
	"\x10fts_retrieval_ms\x18\x05 \x01(\x03R\x0eftsRetrievalMs\x12(\n" +
	"\x10llm_reranking_ms\x18\x06 \x01(\x03R\x0ellmRerankingMs\x12\x19\n" +
	"\btotal_ms\x18\a \x01(\x03R\atotalMs\x12%\n" +
	"\x0eexpanded_terms\x18\b \x03(\tR\rexpandedTerms\"\xf6\x03\n" +
	"\vIndexedTool\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12 \n" +
	"\vdescription\x18\x03 \x01(\tR\vdescription\x12+\n" +
	"\x06source\x18\x04 \x01(\x0e2\x13.loom.v1.ToolSourceR\x06source\x12\x1d\n" +
	"\n" +
	"mcp_server\x18\x05 \x01(\tR\tmcpServer\x12!\n" +
	"\finput_schema\x18\x06 \x01(\tR\vinputSchema\x12#\n" +
	"\routput_schema\x18\a \x01(\tR\foutputSchema\x12\"\n" +
	"\fcapabilities\x18\b \x03(\tR\fcapabilities\x12\x1a\n" +
	"\bkeywords\x18\t \x03(\tR\bkeywords\x120\n" +
	"\bexamples\x18\n" +
	" \x03(\v2\x14.loom.v1.ToolExampleR\bexamples\x12\x1d\n" +
	"\n" +
	"indexed_at\x18\v \x01(\tR\tindexedAt\x12\x18\n" +
	"\aversion\x18\f \x01(\tR\aversion\x12+\n" +
	"\x11requires_approval\x18\r \x01(\bR\x10requiresApproval\x125\n" +
	"\n" +
	"rate_limit\x18\x0e \x01(\v2\x16.loom.v1.RateLimitInfoR\trateLimit\"]\n" +
	"\vToolExample\x12 \n" +
	"\vdescription\x18\x01 \x01(\tR\vdescription\x12\x14\n" +
	"\x05input\x18\x02 \x01(\tR\x05input\x12\x16\n" +
	"\x06output\x18\x03 \x01(\tR\x06output\"\x81\x01\n" +
	"\rRateLimitInfo\x12.\n" +
	"\x13requests_per_minute\x18\x01 \x01(\x05R\x11requestsPerMinute\x12*\n" +
	"\x11requests_per_hour\x18\x02 \x01(\x05R\x0frequestsPerHour\x12\x14\n" +
	"\x05notes\x18\x03 \x01(\tR\x05notes\"\x86\x01\n" +
	"\x11IndexToolsRequest\x12!\n" +
	"\ffull_reindex\x18\x01 \x01(\bR\vfullReindex\x12-\n" +
	"\asources\x18\x02 \x03(\x0e2\x13.loom.v1.ToolSourceR\asources\x12\x1f\n" +
	"\vmcp_servers\x18\x03 \x03(\tR\n" +
	"mcpServers\"\xe8\x01\n" +
	"\x12IndexToolsResponse\x12#\n" +
	"\rbuiltin_count\x18\x01 \x01(\x05R\fbuiltinCount\x12\x1b\n" +
	"\tmcp_count\x18\x02 \x01(\x05R\bmcpCount\x12!\n" +
	"\fcustom_count\x18\x03 \x01(\x05R\vcustomCount\x12\x1f\n" +
	"\vtotal_count\x18\x04 \x01(\x05R\n" +
	"totalCount\x12+\n" +
	"\x06errors\x18\x05 \x03(\v2\x13.loom.v1.IndexErrorR\x06errors\x12\x1f\n" +
	"\vduration_ms\x18\x06 \x01(\x03R\n" +
	"durationMs\"\x7f\n" +
	"\n" +
	"IndexError\x12+\n" +
	"\x06source\x18\x01 \x01(\x0e2\x13.loom.v1.ToolSourceR\x06source\x12\x1f\n" +
	"\vserver_name\x18\x02 \x01(\tR\n" +
	"serverName\x12#\n" +
	"\rerror_message\x18\x03 \x01(\tR\ferrorMessage\"\x18\n" +
	"\x16ListToolSourcesRequest\"L\n" +
	"\x17ListToolSourcesResponse\x121\n" +
	"\asources\x18\x01 \x03(\v2\x17.loom.v1.ToolSourceInfoR\asources\"\xf6\x01\n" +
	"\x0eToolSourceInfo\x12'\n" +
	"\x04type\x18\x01 \x01(\x0e2\x13.loom.v1.ToolSourceR\x04type\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12 \n" +
	"\vdescription\x18\x03 \x01(\tR\vdescription\x12\x1d\n" +
	"\n" +
	"tool_count\x18\x04 \x01(\x05R\ttoolCount\x12!\n" +
	"\flast_indexed\x18\x05 \x01(\tR\vlastIndexed\x12\x1c\n" +
	"\tavailable\x18\x06 \x01(\bR\tavailable\x12%\n" +
	"\x0estatus_message\x18\a \x01(\tR\rstatusMessage\"|\n" +
	"\x15GetIndexedToolRequest\x12\x17\n" +
	"\atool_id\x18\x01 \x01(\tR\x06toolId\x12+\n" +
	"\x06source\x18\x02 \x01(\x0e2\x13.loom.v1.ToolSourceR\x06source\x12\x1d\n" +
	"\n" +
	"mcp_server\x18\x03 \x01(\tR\tmcpServer\"\x9a\x01\n" +
	"\x1bGetToolsByCapabilityRequest\x12\x1e\n" +
	"\n" +
	"capability\x18\x01 \x01(\tR\n" +
	"capability\x12:\n" +
	"\x0esource_filters\x18\x02 \x03(\x0e2\x13.loom.v1.ToolSourceR\rsourceFilters\x12\x1f\n" +
	"\vmax_results\x18\x03 \x01(\x05R\n" +
	"maxResults\"J\n" +
	"\x1cGetToolsByCapabilityResponse\x12*\n" +
	"\x05tools\x18\x01 \x03(\v2\x14.loom.v1.IndexedToolR\x05tools*s\n" +
	"\n" +
	"SearchMode\x12\x1b\n" +
	"\x17SEARCH_MODE_UNSPECIFIED\x10\x00\x12\x14\n" +
	"\x10SEARCH_MODE_FAST\x10\x01\x12\x18\n" +
	"\x14SEARCH_MODE_BALANCED\x10\x02\x12\x18\n" +
	"\x14SEARCH_MODE_ACCURATE\x10\x03*o\n" +
	"\n" +
	"ToolSource\x12\x1b\n" +
	"\x17TOOL_SOURCE_UNSPECIFIED\x10\x00\x12\x17\n" +
	"\x13TOOL_SOURCE_BUILTIN\x10\x01\x12\x13\n" +
	"\x0fTOOL_SOURCE_MCP\x10\x02\x12\x16\n" +
	"\x12TOOL_SOURCE_CUSTOM\x10\x032\xa9\x03\n" +
	"\x13ToolRegistryService\x12H\n" +
	"\vSearchTools\x12\x1b.loom.v1.SearchToolsRequest\x1a\x1c.loom.v1.SearchToolsResponse\x12E\n" +
	"\n" +
	"IndexTools\x12\x1a.loom.v1.IndexToolsRequest\x1a\x1b.loom.v1.IndexToolsResponse\x12T\n" +
	"\x0fListToolSources\x12\x1f.loom.v1.ListToolSourcesRequest\x1a .loom.v1.ListToolSourcesResponse\x12F\n" +
	"\x0eGetIndexedTool\x12\x1e.loom.v1.GetIndexedToolRequest\x1a\x14.loom.v1.IndexedTool\x12c\n" +
	"\x14GetToolsByCapability\x12$.loom.v1.GetToolsByCapabilityRequest\x1a%.loom.v1.GetToolsByCapabilityResponseB5Z3github.com/teradata-labs/loom/gen/go/loom/v1;loomv1b\x06proto3"

var (
	file_loom_v1_tools_proto_rawDescOnce sync.Once
	file_loom_v1_tools_proto_rawDescData []byte
)

func file_loom_v1_tools_proto_rawDescGZIP() []byte {
	file_loom_v1_tools_proto_rawDescOnce.Do(func() {
		file_loom_v1_tools_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_loom_v1_tools_proto_rawDesc), len(file_loom_v1_tools_proto_rawDesc)))
	})
	return file_loom_v1_tools_proto_rawDescData
}

var file_loom_v1_tools_proto_enumTypes = make([]protoimpl.EnumInfo, 2)
var file_loom_v1_tools_proto_msgTypes = make([]protoimpl.MessageInfo, 17)
var file_loom_v1_tools_proto_goTypes = []any{
	(SearchMode)(0),                      // 0: loom.v1.SearchMode
	(ToolSource)(0),                      // 1: loom.v1.ToolSource
	(*SearchToolsRequest)(nil),           // 2: loom.v1.SearchToolsRequest
	(*SearchToolsResponse)(nil),          // 3: loom.v1.SearchToolsResponse
	(*ToolSearchResult)(nil),             // 4: loom.v1.ToolSearchResult
	(*RelevanceSignal)(nil),              // 5: loom.v1.RelevanceSignal
	(*SearchMetadata)(nil),               // 6: loom.v1.SearchMetadata
	(*IndexedTool)(nil),                  // 7: loom.v1.IndexedTool
	(*ToolExample)(nil),                  // 8: loom.v1.ToolExample
	(*RateLimitInfo)(nil),                // 9: loom.v1.RateLimitInfo
	(*IndexToolsRequest)(nil),            // 10: loom.v1.IndexToolsRequest
	(*IndexToolsResponse)(nil),           // 11: loom.v1.IndexToolsResponse
	(*IndexError)(nil),                   // 12: loom.v1.IndexError
	(*ListToolSourcesRequest)(nil),       // 13: loom.v1.ListToolSourcesRequest
	(*ListToolSourcesResponse)(nil),      // 14: loom.v1.ListToolSourcesResponse
	(*ToolSourceInfo)(nil),               // 15: loom.v1.ToolSourceInfo
	(*GetIndexedToolRequest)(nil),        // 16: loom.v1.GetIndexedToolRequest
	(*GetToolsByCapabilityRequest)(nil),  // 17: loom.v1.GetToolsByCapabilityRequest
	(*GetToolsByCapabilityResponse)(nil), // 18: loom.v1.GetToolsByCapabilityResponse
}
var file_loom_v1_tools_proto_depIdxs = []int32{
	0,  // 0: loom.v1.SearchToolsRequest.mode:type_name -> loom.v1.SearchMode
	1,  // 1: loom.v1.SearchToolsRequest.source_filters:type_name -> loom.v1.ToolSource
	4,  // 2: loom.v1.SearchToolsResponse.results:type_name -> loom.v1.ToolSearchResult
	6,  // 3: loom.v1.SearchToolsResponse.metadata:type_name -> loom.v1.SearchMetadata
	7,  // 4: loom.v1.ToolSearchResult.tool:type_name -> loom.v1.IndexedTool
	5,  // 5: loom.v1.ToolSearchResult.signals:type_name -> loom.v1.RelevanceSignal
	0,  // 6: loom.v1.SearchMetadata.mode_used:type_name -> loom.v1.SearchMode
	1,  // 7: loom.v1.IndexedTool.source:type_name -> loom.v1.ToolSource
	8,  // 8: loom.v1.IndexedTool.examples:type_name -> loom.v1.ToolExample
	9,  // 9: loom.v1.IndexedTool.rate_limit:type_name -> loom.v1.RateLimitInfo
	1,  // 10: loom.v1.IndexToolsRequest.sources:type_name -> loom.v1.ToolSource
	12, // 11: loom.v1.IndexToolsResponse.errors:type_name -> loom.v1.IndexError
	1,  // 12: loom.v1.IndexError.source:type_name -> loom.v1.ToolSource
	15, // 13: loom.v1.ListToolSourcesResponse.sources:type_name -> loom.v1.ToolSourceInfo
	1,  // 14: loom.v1.ToolSourceInfo.type:type_name -> loom.v1.ToolSource
	1,  // 15: loom.v1.GetIndexedToolRequest.source:type_name -> loom.v1.ToolSource
	1,  // 16: loom.v1.GetToolsByCapabilityRequest.source_filters:type_name -> loom.v1.ToolSource
	7,  // 17: loom.v1.GetToolsByCapabilityResponse.tools:type_name -> loom.v1.IndexedTool
	2,  // 18: loom.v1.ToolRegistryService.SearchTools:input_type -> loom.v1.SearchToolsRequest
	10, // 19: loom.v1.ToolRegistryService.IndexTools:input_type -> loom.v1.IndexToolsRequest
	13, // 20: loom.v1.ToolRegistryService.ListToolSources:input_type -> loom.v1.ListToolSourcesRequest
	16, // 21: loom.v1.ToolRegistryService.GetIndexedTool:input_type -> loom.v1.GetIndexedToolRequest
	17, // 22: loom.v1.ToolRegistryService.GetToolsByCapability:input_type -> loom.v1.GetToolsByCapabilityRequest
	3,  // 23: loom.v1.ToolRegistryService.SearchTools:output_type -> loom.v1.SearchToolsResponse
	11, // 24: loom.v1.ToolRegistryService.IndexTools:output_type -> loom.v1.IndexToolsResponse
	14, // 25: loom.v1.ToolRegistryService.ListToolSources:output_type -> loom.v1.ListToolSourcesResponse
	7,  // 26: loom.v1.ToolRegistryService.GetIndexedTool:output_type -> loom.v1.IndexedTool
	18, // 27: loom.v1.ToolRegistryService.GetToolsByCapability:output_type -> loom.v1.GetToolsByCapabilityResponse
	23, // [23:28] is the sub-list for method output_type
	18, // [18:23] is the sub-list for method input_type
	18, // [18:18] is the sub-list for extension type_name
	18, // [18:18] is the sub-list for extension extendee
	0,  // [0:18] is the sub-list for field type_name
}

func init() { file_loom_v1_tools_proto_init() }
func file_loom_v1_tools_proto_init() {
	if File_loom_v1_tools_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_loom_v1_tools_proto_rawDesc), len(file_loom_v1_tools_proto_rawDesc)),
			NumEnums:      2,
			NumMessages:   17,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_loom_v1_tools_proto_goTypes,
		DependencyIndexes: file_loom_v1_tools_proto_depIdxs,
		EnumInfos:         file_loom_v1_tools_proto_enumTypes,
		MessageInfos:      file_loom_v1_tools_proto_msgTypes,
	}.Build()
	File_loom_v1_tools_proto = out.File
	file_loom_v1_tools_proto_goTypes = nil
	file_loom_v1_tools_proto_depIdxs = nil
}

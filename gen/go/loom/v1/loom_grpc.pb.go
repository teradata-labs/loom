// Copyright 2026 Teradata
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             (unknown)
// source: loom/v1/loom.proto

package loomv1

import (
	context "context"

	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	LoomService_Weave_FullMethodName                       = "/loom.v1.LoomService/Weave"
	LoomService_StreamWeave_FullMethodName                 = "/loom.v1.LoomService/StreamWeave"
	LoomService_LoadPatterns_FullMethodName                = "/loom.v1.LoomService/LoadPatterns"
	LoomService_ListPatterns_FullMethodName                = "/loom.v1.LoomService/ListPatterns"
	LoomService_GetPattern_FullMethodName                  = "/loom.v1.LoomService/GetPattern"
	LoomService_CreatePattern_FullMethodName               = "/loom.v1.LoomService/CreatePattern"
	LoomService_StreamPatternUpdates_FullMethodName        = "/loom.v1.LoomService/StreamPatternUpdates"
	LoomService_AnswerClarificationQuestion_FullMethodName = "/loom.v1.LoomService/AnswerClarificationQuestion"
	LoomService_CreateSession_FullMethodName               = "/loom.v1.LoomService/CreateSession"
	LoomService_GetSession_FullMethodName                  = "/loom.v1.LoomService/GetSession"
	LoomService_ListSessions_FullMethodName                = "/loom.v1.LoomService/ListSessions"
	LoomService_DeleteSession_FullMethodName               = "/loom.v1.LoomService/DeleteSession"
	LoomService_SubscribeToSession_FullMethodName          = "/loom.v1.LoomService/SubscribeToSession"
	LoomService_GetConversationHistory_FullMethodName      = "/loom.v1.LoomService/GetConversationHistory"
	LoomService_RegisterTool_FullMethodName                = "/loom.v1.LoomService/RegisterTool"
	LoomService_ListTools_FullMethodName                   = "/loom.v1.LoomService/ListTools"
	LoomService_GetTrace_FullMethodName                    = "/loom.v1.LoomService/GetTrace"
	LoomService_GetHealth_FullMethodName                   = "/loom.v1.LoomService/GetHealth"
	LoomService_GetServerConfig_FullMethodName             = "/loom.v1.LoomService/GetServerConfig"
	LoomService_GetTLSStatus_FullMethodName                = "/loom.v1.LoomService/GetTLSStatus"
	LoomService_RenewCertificate_FullMethodName            = "/loom.v1.LoomService/RenewCertificate"
	LoomService_CreateAgentFromConfig_FullMethodName       = "/loom.v1.LoomService/CreateAgentFromConfig"
	LoomService_ListAgents_FullMethodName                  = "/loom.v1.LoomService/ListAgents"
	LoomService_GetAgent_FullMethodName                    = "/loom.v1.LoomService/GetAgent"
	LoomService_StartAgent_FullMethodName                  = "/loom.v1.LoomService/StartAgent"
	LoomService_StopAgent_FullMethodName                   = "/loom.v1.LoomService/StopAgent"
	LoomService_DeleteAgent_FullMethodName                 = "/loom.v1.LoomService/DeleteAgent"
	LoomService_ReloadAgent_FullMethodName                 = "/loom.v1.LoomService/ReloadAgent"
	LoomService_SwitchModel_FullMethodName                 = "/loom.v1.LoomService/SwitchModel"
	LoomService_ListAvailableModels_FullMethodName         = "/loom.v1.LoomService/ListAvailableModels"
	LoomService_RequestToolPermission_FullMethodName       = "/loom.v1.LoomService/RequestToolPermission"
	LoomService_ListMCPServers_FullMethodName              = "/loom.v1.LoomService/ListMCPServers"
	LoomService_GetMCPServer_FullMethodName                = "/loom.v1.LoomService/GetMCPServer"
	LoomService_AddMCPServer_FullMethodName                = "/loom.v1.LoomService/AddMCPServer"
	LoomService_UpdateMCPServer_FullMethodName             = "/loom.v1.LoomService/UpdateMCPServer"
	LoomService_DeleteMCPServer_FullMethodName             = "/loom.v1.LoomService/DeleteMCPServer"
	LoomService_RestartMCPServer_FullMethodName            = "/loom.v1.LoomService/RestartMCPServer"
	LoomService_HealthCheckMCPServers_FullMethodName       = "/loom.v1.LoomService/HealthCheckMCPServers"
	LoomService_TestMCPServerConnection_FullMethodName     = "/loom.v1.LoomService/TestMCPServerConnection"
	LoomService_ListMCPServerTools_FullMethodName          = "/loom.v1.LoomService/ListMCPServerTools"
	LoomService_ExecuteWorkflow_FullMethodName             = "/loom.v1.LoomService/ExecuteWorkflow"
	LoomService_StreamWorkflow_FullMethodName              = "/loom.v1.LoomService/StreamWorkflow"
	LoomService_GetWorkflowExecution_FullMethodName        = "/loom.v1.LoomService/GetWorkflowExecution"
	LoomService_ListWorkflowExecutions_FullMethodName      = "/loom.v1.LoomService/ListWorkflowExecutions"
	LoomService_ScheduleWorkflow_FullMethodName            = "/loom.v1.LoomService/ScheduleWorkflow"
	LoomService_UpdateScheduledWorkflow_FullMethodName     = "/loom.v1.LoomService/UpdateScheduledWorkflow"
	LoomService_GetScheduledWorkflow_FullMethodName        = "/loom.v1.LoomService/GetScheduledWorkflow"
	LoomService_ListScheduledWorkflows_FullMethodName      = "/loom.v1.LoomService/ListScheduledWorkflows"
	LoomService_DeleteScheduledWorkflow_FullMethodName     = "/loom.v1.LoomService/DeleteScheduledWorkflow"
	LoomService_TriggerScheduledWorkflow_FullMethodName    = "/loom.v1.LoomService/TriggerScheduledWorkflow"
	LoomService_PauseSchedule_FullMethodName               = "/loom.v1.LoomService/PauseSchedule"
	LoomService_ResumeSchedule_FullMethodName              = "/loom.v1.LoomService/ResumeSchedule"
	LoomService_GetScheduleHistory_FullMethodName          = "/loom.v1.LoomService/GetScheduleHistory"
	LoomService_Publish_FullMethodName                     = "/loom.v1.LoomService/Publish"
	LoomService_Subscribe_FullMethodName                   = "/loom.v1.LoomService/Subscribe"
	LoomService_Unsubscribe_FullMethodName                 = "/loom.v1.LoomService/Unsubscribe"
	LoomService_ListTopics_FullMethodName                  = "/loom.v1.LoomService/ListTopics"
	LoomService_GetTopicStats_FullMethodName               = "/loom.v1.LoomService/GetTopicStats"
	LoomService_SendAsync_FullMethodName                   = "/loom.v1.LoomService/SendAsync"
	LoomService_SendAndReceive_FullMethodName              = "/loom.v1.LoomService/SendAndReceive"
	LoomService_PutSharedMemory_FullMethodName             = "/loom.v1.LoomService/PutSharedMemory"
	LoomService_GetSharedMemory_FullMethodName             = "/loom.v1.LoomService/GetSharedMemory"
	LoomService_DeleteSharedMemory_FullMethodName          = "/loom.v1.LoomService/DeleteSharedMemory"
	LoomService_WatchSharedMemory_FullMethodName           = "/loom.v1.LoomService/WatchSharedMemory"
	LoomService_ListSharedMemoryKeys_FullMethodName        = "/loom.v1.LoomService/ListSharedMemoryKeys"
	LoomService_GetSharedMemoryStats_FullMethodName        = "/loom.v1.LoomService/GetSharedMemoryStats"
	LoomService_ListArtifacts_FullMethodName               = "/loom.v1.LoomService/ListArtifacts"
	LoomService_GetArtifact_FullMethodName                 = "/loom.v1.LoomService/GetArtifact"
	LoomService_UploadArtifact_FullMethodName              = "/loom.v1.LoomService/UploadArtifact"
	LoomService_DeleteArtifact_FullMethodName              = "/loom.v1.LoomService/DeleteArtifact"
	LoomService_SearchArtifacts_FullMethodName             = "/loom.v1.LoomService/SearchArtifacts"
	LoomService_GetArtifactContent_FullMethodName          = "/loom.v1.LoomService/GetArtifactContent"
	LoomService_GetArtifactStats_FullMethodName            = "/loom.v1.LoomService/GetArtifactStats"
)

// LoomServiceClient is the client API for LoomService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// LoomService provides the core agent runtime API for multi-domain
// autonomous LLM agents with pattern-guided learning and self-correction.
type LoomServiceClient interface {
	// Weave executes a user query by selecting patterns, executing tools,
	// and weaving LLM intelligence with domain knowledge.
	Weave(ctx context.Context, in *WeaveRequest, opts ...grpc.CallOption) (*WeaveResponse, error)
	// StreamWeave executes a query and streams incremental progress updates.
	StreamWeave(ctx context.Context, in *WeaveRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[WeaveProgress], error)
	// LoadPatterns loads pattern definitions from a directory or repository.
	LoadPatterns(ctx context.Context, in *LoadPatternsRequest, opts ...grpc.CallOption) (*LoadPatternsResponse, error)
	// ListPatterns retrieves available patterns with optional filtering.
	ListPatterns(ctx context.Context, in *ListPatternsRequest, opts ...grpc.CallOption) (*ListPatternsResponse, error)
	// GetPattern retrieves a specific pattern by name.
	GetPattern(ctx context.Context, in *GetPatternRequest, opts ...grpc.CallOption) (*Pattern, error)
	// CreatePattern creates a new pattern at runtime.
	CreatePattern(ctx context.Context, in *CreatePatternRequest, opts ...grpc.CallOption) (*CreatePatternResponse, error)
	// StreamPatternUpdates streams real-time pattern updates (additions, changes, deletions).
	// Used by TUI and other clients to show live pattern library changes.
	StreamPatternUpdates(ctx context.Context, in *StreamPatternUpdatesRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[PatternUpdateEvent], error)
	// AnswerClarificationQuestion provides an answer to a clarification question asked by an agent.
	// Used by TUI and other clients to respond to EventQuestionAsked progress events.
	AnswerClarificationQuestion(ctx context.Context, in *AnswerClarificationRequest, opts ...grpc.CallOption) (*AnswerClarificationResponse, error)
	// CreateSession creates a new conversation session.
	CreateSession(ctx context.Context, in *CreateSessionRequest, opts ...grpc.CallOption) (*Session, error)
	// GetSession retrieves session details.
	GetSession(ctx context.Context, in *GetSessionRequest, opts ...grpc.CallOption) (*Session, error)
	// ListSessions lists all sessions with optional filtering.
	ListSessions(ctx context.Context, in *ListSessionsRequest, opts ...grpc.CallOption) (*ListSessionsResponse, error)
	// DeleteSession deletes a session and its history.
	DeleteSession(ctx context.Context, in *DeleteSessionRequest, opts ...grpc.CallOption) (*DeleteSessionResponse, error)
	// SubscribeToSession subscribes to real-time updates for a session.
	// Returns a stream of updates when new messages arrive or session state changes.
	// This allows clients to receive asynchronous responses from workflow coordinators
	// and sub-agents without polling.
	SubscribeToSession(ctx context.Context, in *SubscribeToSessionRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[SessionUpdate], error)
	// GetConversationHistory retrieves conversation history for a session.
	GetConversationHistory(ctx context.Context, in *GetConversationHistoryRequest, opts ...grpc.CallOption) (*ConversationHistory, error)
	// RegisterTool dynamically registers a new tool.
	RegisterTool(ctx context.Context, in *RegisterToolRequest, opts ...grpc.CallOption) (*RegisterToolResponse, error)
	// ListTools lists all registered tools.
	ListTools(ctx context.Context, in *ListToolsRequest, opts ...grpc.CallOption) (*ListToolsResponse, error)
	// GetTrace retrieves execution trace for observability.
	GetTrace(ctx context.Context, in *GetTraceRequest, opts ...grpc.CallOption) (*Trace, error)
	// GetHealth returns health status of the agent.
	GetHealth(ctx context.Context, in *GetHealthRequest, opts ...grpc.CallOption) (*HealthStatus, error)
	// GetServerConfig retrieves the current server configuration.
	GetServerConfig(ctx context.Context, in *GetServerConfigRequest, opts ...grpc.CallOption) (*ServerConfig, error)
	// GetTLSStatus retrieves the current TLS/certificate status.
	GetTLSStatus(ctx context.Context, in *GetTLSStatusRequest, opts ...grpc.CallOption) (*TLSStatus, error)
	// RenewCertificate manually triggers certificate renewal (for Let's Encrypt).
	RenewCertificate(ctx context.Context, in *RenewCertificateRequest, opts ...grpc.CallOption) (*RenewCertificateResponse, error)
	// CreateAgentFromConfig creates an agent from configuration.
	CreateAgentFromConfig(ctx context.Context, in *CreateAgentRequest, opts ...grpc.CallOption) (*AgentInfo, error)
	// ListAgents lists all registered agents.
	ListAgents(ctx context.Context, in *ListAgentsRequest, opts ...grpc.CallOption) (*ListAgentsResponse, error)
	// GetAgent retrieves agent information.
	GetAgent(ctx context.Context, in *GetAgentRequest, opts ...grpc.CallOption) (*AgentInfo, error)
	// StartAgent starts a stopped agent.
	StartAgent(ctx context.Context, in *StartAgentRequest, opts ...grpc.CallOption) (*AgentInfo, error)
	// StopAgent stops a running agent.
	StopAgent(ctx context.Context, in *StopAgentRequest, opts ...grpc.CallOption) (*AgentInfo, error)
	// DeleteAgent deletes an agent.
	DeleteAgent(ctx context.Context, in *DeleteAgentRequest, opts ...grpc.CallOption) (*DeleteAgentResponse, error)
	// ReloadAgent hot-reloads agent configuration without stopping.
	ReloadAgent(ctx context.Context, in *ReloadAgentRequest, opts ...grpc.CallOption) (*AgentInfo, error)
	// SwitchModel switches the LLM model/provider for a session without losing context.
	SwitchModel(ctx context.Context, in *SwitchModelRequest, opts ...grpc.CallOption) (*SwitchModelResponse, error)
	// ListAvailableModels lists all available LLM models/providers.
	ListAvailableModels(ctx context.Context, in *ListAvailableModelsRequest, opts ...grpc.CallOption) (*ListAvailableModelsResponse, error)
	// RequestToolPermission requests user permission to execute a tool.
	RequestToolPermission(ctx context.Context, in *ToolPermissionRequest, opts ...grpc.CallOption) (*ToolPermissionResponse, error)
	// ListMCPServers lists all configured MCP servers.
	ListMCPServers(ctx context.Context, in *ListMCPServersRequest, opts ...grpc.CallOption) (*ListMCPServersResponse, error)
	// GetMCPServer retrieves a specific MCP server configuration.
	GetMCPServer(ctx context.Context, in *GetMCPServerRequest, opts ...grpc.CallOption) (*MCPServerInfo, error)
	// AddMCPServer adds a new MCP server configuration.
	AddMCPServer(ctx context.Context, in *AddMCPServerRequest, opts ...grpc.CallOption) (*AddMCPServerResponse, error)
	// UpdateMCPServer updates an existing MCP server configuration.
	UpdateMCPServer(ctx context.Context, in *UpdateMCPServerRequest, opts ...grpc.CallOption) (*MCPServerInfo, error)
	// DeleteMCPServer removes an MCP server configuration.
	DeleteMCPServer(ctx context.Context, in *DeleteMCPServerRequest, opts ...grpc.CallOption) (*DeleteMCPServerResponse, error)
	// RestartMCPServer restarts a running MCP server.
	RestartMCPServer(ctx context.Context, in *RestartMCPServerRequest, opts ...grpc.CallOption) (*MCPServerInfo, error)
	// HealthCheckMCPServers checks health of all MCP servers.
	HealthCheckMCPServers(ctx context.Context, in *HealthCheckMCPServersRequest, opts ...grpc.CallOption) (*HealthCheckMCPServersResponse, error)
	// TestMCPServerConnection tests an MCP server configuration without persisting it.
	// This allows users to validate their configuration (command, args, env vars) before saving.
	TestMCPServerConnection(ctx context.Context, in *TestMCPServerConnectionRequest, opts ...grpc.CallOption) (*TestMCPServerConnectionResponse, error)
	// ListMCPServerTools lists all tools from a specific MCP server.
	// This queries the MCP server directly through the manager, not the agent's tool registry.
	ListMCPServerTools(ctx context.Context, in *ListMCPServerToolsRequest, opts ...grpc.CallOption) (*ListMCPServerToolsResponse, error)
	// ExecuteWorkflow executes a multi-agent workflow pattern.
	ExecuteWorkflow(ctx context.Context, in *ExecuteWorkflowRequest, opts ...grpc.CallOption) (*ExecuteWorkflowResponse, error)
	// StreamWorkflow executes a workflow and streams progress updates.
	StreamWorkflow(ctx context.Context, in *ExecuteWorkflowRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[WorkflowProgress], error)
	// GetWorkflowExecution retrieves a workflow execution.
	GetWorkflowExecution(ctx context.Context, in *GetWorkflowExecutionRequest, opts ...grpc.CallOption) (*WorkflowExecution, error)
	// ListWorkflowExecutions lists workflow executions.
	ListWorkflowExecutions(ctx context.Context, in *ListWorkflowExecutionsRequest, opts ...grpc.CallOption) (*ListWorkflowExecutionsResponse, error)
	// ScheduleWorkflow creates a new scheduled workflow.
	ScheduleWorkflow(ctx context.Context, in *ScheduleWorkflowRequest, opts ...grpc.CallOption) (*ScheduleWorkflowResponse, error)
	// UpdateScheduledWorkflow updates an existing scheduled workflow.
	UpdateScheduledWorkflow(ctx context.Context, in *UpdateScheduledWorkflowRequest, opts ...grpc.CallOption) (*ScheduleWorkflowResponse, error)
	// GetScheduledWorkflow retrieves a scheduled workflow by ID.
	GetScheduledWorkflow(ctx context.Context, in *GetScheduledWorkflowRequest, opts ...grpc.CallOption) (*ScheduledWorkflow, error)
	// ListScheduledWorkflows lists all scheduled workflows.
	ListScheduledWorkflows(ctx context.Context, in *ListScheduledWorkflowsRequest, opts ...grpc.CallOption) (*ListScheduledWorkflowsResponse, error)
	// DeleteScheduledWorkflow deletes a scheduled workflow.
	DeleteScheduledWorkflow(ctx context.Context, in *DeleteScheduledWorkflowRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// TriggerScheduledWorkflow manually triggers a scheduled workflow immediately.
	TriggerScheduledWorkflow(ctx context.Context, in *TriggerScheduledWorkflowRequest, opts ...grpc.CallOption) (*ExecuteWorkflowResponse, error)
	// PauseSchedule pauses a schedule without deleting it.
	PauseSchedule(ctx context.Context, in *PauseScheduleRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// ResumeSchedule resumes a paused schedule.
	ResumeSchedule(ctx context.Context, in *ResumeScheduleRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// GetScheduleHistory retrieves execution history for a schedule.
	GetScheduleHistory(ctx context.Context, in *GetScheduleHistoryRequest, opts ...grpc.CallOption) (*GetScheduleHistoryResponse, error)
	// Publish publishes a message to a topic (one-to-many broadcast).
	Publish(ctx context.Context, in *PublishRequest, opts ...grpc.CallOption) (*PublishResponse, error)
	// Subscribe subscribes to a topic and receives messages via stream.
	Subscribe(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[BusMessage], error)
	// Unsubscribe cancels a topic subscription.
	Unsubscribe(ctx context.Context, in *UnsubscribeRequest, opts ...grpc.CallOption) (*UnsubscribeResponse, error)
	// ListTopics lists all active topics.
	ListTopics(ctx context.Context, in *ListTopicsRequest, opts ...grpc.CallOption) (*ListTopicsResponse, error)
	// GetTopicStats retrieves statistics for a topic.
	GetTopicStats(ctx context.Context, in *GetTopicStatsRequest, opts ...grpc.CallOption) (*TopicStats, error)
	// SendAsync sends a message asynchronously (fire-and-forget).
	SendAsync(ctx context.Context, in *SendAsyncRequest, opts ...grpc.CallOption) (*SendAsyncResponse, error)
	// SendAndReceive sends a message and waits for response (RPC-style).
	SendAndReceive(ctx context.Context, in *SendAndReceiveRequest, opts ...grpc.CallOption) (*SendAndReceiveResponse, error)
	// PutSharedMemory writes or updates a value in shared memory.
	PutSharedMemory(ctx context.Context, in *PutSharedMemoryRequest, opts ...grpc.CallOption) (*PutSharedMemoryResponse, error)
	// GetSharedMemory reads a value from shared memory.
	GetSharedMemory(ctx context.Context, in *GetSharedMemoryRequest, opts ...grpc.CallOption) (*GetSharedMemoryResponse, error)
	// DeleteSharedMemory removes a value from shared memory.
	DeleteSharedMemory(ctx context.Context, in *DeleteSharedMemoryRequest, opts ...grpc.CallOption) (*DeleteSharedMemoryResponse, error)
	// WatchSharedMemory watches for changes to keys in a namespace.
	WatchSharedMemory(ctx context.Context, in *WatchSharedMemoryRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[SharedMemoryValue], error)
	// ListSharedMemoryKeys lists all keys in a namespace.
	ListSharedMemoryKeys(ctx context.Context, in *ListSharedMemoryKeysRequest, opts ...grpc.CallOption) (*ListSharedMemoryKeysResponse, error)
	// GetSharedMemoryStats retrieves statistics for a namespace.
	GetSharedMemoryStats(ctx context.Context, in *GetSharedMemoryStatsRequest, opts ...grpc.CallOption) (*SharedMemoryStats, error)
	// ListArtifacts lists artifacts with optional filtering.
	ListArtifacts(ctx context.Context, in *ListArtifactsRequest, opts ...grpc.CallOption) (*ListArtifactsResponse, error)
	// GetArtifact retrieves artifact metadata.
	GetArtifact(ctx context.Context, in *GetArtifactRequest, opts ...grpc.CallOption) (*GetArtifactResponse, error)
	// UploadArtifact uploads a file to artifacts storage.
	UploadArtifact(ctx context.Context, in *UploadArtifactRequest, opts ...grpc.CallOption) (*UploadArtifactResponse, error)
	// DeleteArtifact deletes an artifact (soft or hard delete).
	DeleteArtifact(ctx context.Context, in *DeleteArtifactRequest, opts ...grpc.CallOption) (*DeleteArtifactResponse, error)
	// SearchArtifacts performs full-text search on artifacts.
	SearchArtifacts(ctx context.Context, in *SearchArtifactsRequest, opts ...grpc.CallOption) (*SearchArtifactsResponse, error)
	// GetArtifactContent reads artifact file content.
	GetArtifactContent(ctx context.Context, in *GetArtifactContentRequest, opts ...grpc.CallOption) (*GetArtifactContentResponse, error)
	// GetArtifactStats retrieves storage statistics.
	GetArtifactStats(ctx context.Context, in *GetArtifactStatsRequest, opts ...grpc.CallOption) (*GetArtifactStatsResponse, error)
}

type loomServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewLoomServiceClient(cc grpc.ClientConnInterface) LoomServiceClient {
	return &loomServiceClient{cc}
}

func (c *loomServiceClient) Weave(ctx context.Context, in *WeaveRequest, opts ...grpc.CallOption) (*WeaveResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WeaveResponse)
	err := c.cc.Invoke(ctx, LoomService_Weave_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loomServiceClient) StreamWeave(ctx context.Context, in *WeaveRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[WeaveProgress], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &LoomService_ServiceDesc.Streams[0], LoomService_StreamWeave_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[WeaveRequest, WeaveProgress]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type LoomService_StreamWeaveClient = grpc.ServerStreamingClient[WeaveProgress]

func (c *loomServiceClient) LoadPatterns(ctx context.Context, in *LoadPatternsRequest, opts ...grpc.CallOption) (*LoadPatternsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoadPatternsResponse)
	err := c.cc.Invoke(ctx, LoomService_LoadPatterns_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loomServiceClient) ListPatterns(ctx context.Context, in *ListPatternsRequest, opts ...grpc.CallOption) (*ListPatternsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListPatternsResponse)
	err := c.cc.Invoke(ctx, LoomService_ListPatterns_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loomServiceClient) GetPattern(ctx context.Context, in *GetPatternRequest, opts ...grpc.CallOption) (*Pattern, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Pattern)
	err := c.cc.Invoke(ctx, LoomService_GetPattern_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loomServiceClient) CreatePattern(ctx context.Context, in *CreatePatternRequest, opts ...grpc.CallOption) (*CreatePatternResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreatePatternResponse)
	err := c.cc.Invoke(ctx, LoomService_CreatePattern_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loomServiceClient) StreamPatternUpdates(ctx context.Context, in *StreamPatternUpdatesRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[PatternUpdateEvent], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &LoomService_ServiceDesc.Streams[1], LoomService_StreamPatternUpdates_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamPatternUpdatesRequest, PatternUpdateEvent]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type LoomService_StreamPatternUpdatesClient = grpc.ServerStreamingClient[PatternUpdateEvent]

func (c *loomServiceClient) AnswerClarificationQuestion(ctx context.Context, in *AnswerClarificationRequest, opts ...grpc.CallOption) (*AnswerClarificationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AnswerClarificationResponse)
	err := c.cc.Invoke(ctx, LoomService_AnswerClarificationQuestion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loomServiceClient) CreateSession(ctx context.Context, in *CreateSessionRequest, opts ...grpc.CallOption) (*Session, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Session)
	err := c.cc.Invoke(ctx, LoomService_CreateSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loomServiceClient) GetSession(ctx context.Context, in *GetSessionRequest, opts ...grpc.CallOption) (*Session, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Session)
	err := c.cc.Invoke(ctx, LoomService_GetSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loomServiceClient) ListSessions(ctx context.Context, in *ListSessionsRequest, opts ...grpc.CallOption) (*ListSessionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListSessionsResponse)
	err := c.cc.Invoke(ctx, LoomService_ListSessions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loomServiceClient) DeleteSession(ctx context.Context, in *DeleteSessionRequest, opts ...grpc.CallOption) (*DeleteSessionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteSessionResponse)
	err := c.cc.Invoke(ctx, LoomService_DeleteSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loomServiceClient) SubscribeToSession(ctx context.Context, in *SubscribeToSessionRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[SessionUpdate], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &LoomService_ServiceDesc.Streams[2], LoomService_SubscribeToSession_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SubscribeToSessionRequest, SessionUpdate]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type LoomService_SubscribeToSessionClient = grpc.ServerStreamingClient[SessionUpdate]

func (c *loomServiceClient) GetConversationHistory(ctx context.Context, in *GetConversationHistoryRequest, opts ...grpc.CallOption) (*ConversationHistory, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConversationHistory)
	err := c.cc.Invoke(ctx, LoomService_GetConversationHistory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loomServiceClient) RegisterTool(ctx context.Context, in *RegisterToolRequest, opts ...grpc.CallOption) (*RegisterToolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegisterToolResponse)
	err := c.cc.Invoke(ctx, LoomService_RegisterTool_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loomServiceClient) ListTools(ctx context.Context, in *ListToolsRequest, opts ...grpc.CallOption) (*ListToolsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListToolsResponse)
	err := c.cc.Invoke(ctx, LoomService_ListTools_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loomServiceClient) GetTrace(ctx context.Context, in *GetTraceRequest, opts ...grpc.CallOption) (*Trace, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Trace)
	err := c.cc.Invoke(ctx, LoomService_GetTrace_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loomServiceClient) GetHealth(ctx context.Context, in *GetHealthRequest, opts ...grpc.CallOption) (*HealthStatus, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HealthStatus)
	err := c.cc.Invoke(ctx, LoomService_GetHealth_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loomServiceClient) GetServerConfig(ctx context.Context, in *GetServerConfigRequest, opts ...grpc.CallOption) (*ServerConfig, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ServerConfig)
	err := c.cc.Invoke(ctx, LoomService_GetServerConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loomServiceClient) GetTLSStatus(ctx context.Context, in *GetTLSStatusRequest, opts ...grpc.CallOption) (*TLSStatus, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TLSStatus)
	err := c.cc.Invoke(ctx, LoomService_GetTLSStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loomServiceClient) RenewCertificate(ctx context.Context, in *RenewCertificateRequest, opts ...grpc.CallOption) (*RenewCertificateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RenewCertificateResponse)
	err := c.cc.Invoke(ctx, LoomService_RenewCertificate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loomServiceClient) CreateAgentFromConfig(ctx context.Context, in *CreateAgentRequest, opts ...grpc.CallOption) (*AgentInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AgentInfo)
	err := c.cc.Invoke(ctx, LoomService_CreateAgentFromConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loomServiceClient) ListAgents(ctx context.Context, in *ListAgentsRequest, opts ...grpc.CallOption) (*ListAgentsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListAgentsResponse)
	err := c.cc.Invoke(ctx, LoomService_ListAgents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loomServiceClient) GetAgent(ctx context.Context, in *GetAgentRequest, opts ...grpc.CallOption) (*AgentInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AgentInfo)
	err := c.cc.Invoke(ctx, LoomService_GetAgent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loomServiceClient) StartAgent(ctx context.Context, in *StartAgentRequest, opts ...grpc.CallOption) (*AgentInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AgentInfo)
	err := c.cc.Invoke(ctx, LoomService_StartAgent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loomServiceClient) StopAgent(ctx context.Context, in *StopAgentRequest, opts ...grpc.CallOption) (*AgentInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AgentInfo)
	err := c.cc.Invoke(ctx, LoomService_StopAgent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loomServiceClient) DeleteAgent(ctx context.Context, in *DeleteAgentRequest, opts ...grpc.CallOption) (*DeleteAgentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteAgentResponse)
	err := c.cc.Invoke(ctx, LoomService_DeleteAgent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loomServiceClient) ReloadAgent(ctx context.Context, in *ReloadAgentRequest, opts ...grpc.CallOption) (*AgentInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AgentInfo)
	err := c.cc.Invoke(ctx, LoomService_ReloadAgent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loomServiceClient) SwitchModel(ctx context.Context, in *SwitchModelRequest, opts ...grpc.CallOption) (*SwitchModelResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SwitchModelResponse)
	err := c.cc.Invoke(ctx, LoomService_SwitchModel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loomServiceClient) ListAvailableModels(ctx context.Context, in *ListAvailableModelsRequest, opts ...grpc.CallOption) (*ListAvailableModelsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListAvailableModelsResponse)
	err := c.cc.Invoke(ctx, LoomService_ListAvailableModels_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loomServiceClient) RequestToolPermission(ctx context.Context, in *ToolPermissionRequest, opts ...grpc.CallOption) (*ToolPermissionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ToolPermissionResponse)
	err := c.cc.Invoke(ctx, LoomService_RequestToolPermission_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loomServiceClient) ListMCPServers(ctx context.Context, in *ListMCPServersRequest, opts ...grpc.CallOption) (*ListMCPServersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListMCPServersResponse)
	err := c.cc.Invoke(ctx, LoomService_ListMCPServers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loomServiceClient) GetMCPServer(ctx context.Context, in *GetMCPServerRequest, opts ...grpc.CallOption) (*MCPServerInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MCPServerInfo)
	err := c.cc.Invoke(ctx, LoomService_GetMCPServer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loomServiceClient) AddMCPServer(ctx context.Context, in *AddMCPServerRequest, opts ...grpc.CallOption) (*AddMCPServerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddMCPServerResponse)
	err := c.cc.Invoke(ctx, LoomService_AddMCPServer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loomServiceClient) UpdateMCPServer(ctx context.Context, in *UpdateMCPServerRequest, opts ...grpc.CallOption) (*MCPServerInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MCPServerInfo)
	err := c.cc.Invoke(ctx, LoomService_UpdateMCPServer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loomServiceClient) DeleteMCPServer(ctx context.Context, in *DeleteMCPServerRequest, opts ...grpc.CallOption) (*DeleteMCPServerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteMCPServerResponse)
	err := c.cc.Invoke(ctx, LoomService_DeleteMCPServer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loomServiceClient) RestartMCPServer(ctx context.Context, in *RestartMCPServerRequest, opts ...grpc.CallOption) (*MCPServerInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MCPServerInfo)
	err := c.cc.Invoke(ctx, LoomService_RestartMCPServer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loomServiceClient) HealthCheckMCPServers(ctx context.Context, in *HealthCheckMCPServersRequest, opts ...grpc.CallOption) (*HealthCheckMCPServersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HealthCheckMCPServersResponse)
	err := c.cc.Invoke(ctx, LoomService_HealthCheckMCPServers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loomServiceClient) TestMCPServerConnection(ctx context.Context, in *TestMCPServerConnectionRequest, opts ...grpc.CallOption) (*TestMCPServerConnectionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TestMCPServerConnectionResponse)
	err := c.cc.Invoke(ctx, LoomService_TestMCPServerConnection_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loomServiceClient) ListMCPServerTools(ctx context.Context, in *ListMCPServerToolsRequest, opts ...grpc.CallOption) (*ListMCPServerToolsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListMCPServerToolsResponse)
	err := c.cc.Invoke(ctx, LoomService_ListMCPServerTools_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loomServiceClient) ExecuteWorkflow(ctx context.Context, in *ExecuteWorkflowRequest, opts ...grpc.CallOption) (*ExecuteWorkflowResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExecuteWorkflowResponse)
	err := c.cc.Invoke(ctx, LoomService_ExecuteWorkflow_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loomServiceClient) StreamWorkflow(ctx context.Context, in *ExecuteWorkflowRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[WorkflowProgress], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &LoomService_ServiceDesc.Streams[3], LoomService_StreamWorkflow_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ExecuteWorkflowRequest, WorkflowProgress]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type LoomService_StreamWorkflowClient = grpc.ServerStreamingClient[WorkflowProgress]

func (c *loomServiceClient) GetWorkflowExecution(ctx context.Context, in *GetWorkflowExecutionRequest, opts ...grpc.CallOption) (*WorkflowExecution, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WorkflowExecution)
	err := c.cc.Invoke(ctx, LoomService_GetWorkflowExecution_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loomServiceClient) ListWorkflowExecutions(ctx context.Context, in *ListWorkflowExecutionsRequest, opts ...grpc.CallOption) (*ListWorkflowExecutionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListWorkflowExecutionsResponse)
	err := c.cc.Invoke(ctx, LoomService_ListWorkflowExecutions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loomServiceClient) ScheduleWorkflow(ctx context.Context, in *ScheduleWorkflowRequest, opts ...grpc.CallOption) (*ScheduleWorkflowResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ScheduleWorkflowResponse)
	err := c.cc.Invoke(ctx, LoomService_ScheduleWorkflow_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loomServiceClient) UpdateScheduledWorkflow(ctx context.Context, in *UpdateScheduledWorkflowRequest, opts ...grpc.CallOption) (*ScheduleWorkflowResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ScheduleWorkflowResponse)
	err := c.cc.Invoke(ctx, LoomService_UpdateScheduledWorkflow_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loomServiceClient) GetScheduledWorkflow(ctx context.Context, in *GetScheduledWorkflowRequest, opts ...grpc.CallOption) (*ScheduledWorkflow, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ScheduledWorkflow)
	err := c.cc.Invoke(ctx, LoomService_GetScheduledWorkflow_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loomServiceClient) ListScheduledWorkflows(ctx context.Context, in *ListScheduledWorkflowsRequest, opts ...grpc.CallOption) (*ListScheduledWorkflowsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListScheduledWorkflowsResponse)
	err := c.cc.Invoke(ctx, LoomService_ListScheduledWorkflows_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loomServiceClient) DeleteScheduledWorkflow(ctx context.Context, in *DeleteScheduledWorkflowRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, LoomService_DeleteScheduledWorkflow_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loomServiceClient) TriggerScheduledWorkflow(ctx context.Context, in *TriggerScheduledWorkflowRequest, opts ...grpc.CallOption) (*ExecuteWorkflowResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExecuteWorkflowResponse)
	err := c.cc.Invoke(ctx, LoomService_TriggerScheduledWorkflow_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loomServiceClient) PauseSchedule(ctx context.Context, in *PauseScheduleRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, LoomService_PauseSchedule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loomServiceClient) ResumeSchedule(ctx context.Context, in *ResumeScheduleRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, LoomService_ResumeSchedule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loomServiceClient) GetScheduleHistory(ctx context.Context, in *GetScheduleHistoryRequest, opts ...grpc.CallOption) (*GetScheduleHistoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetScheduleHistoryResponse)
	err := c.cc.Invoke(ctx, LoomService_GetScheduleHistory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loomServiceClient) Publish(ctx context.Context, in *PublishRequest, opts ...grpc.CallOption) (*PublishResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PublishResponse)
	err := c.cc.Invoke(ctx, LoomService_Publish_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loomServiceClient) Subscribe(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[BusMessage], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &LoomService_ServiceDesc.Streams[4], LoomService_Subscribe_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SubscribeRequest, BusMessage]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type LoomService_SubscribeClient = grpc.ServerStreamingClient[BusMessage]

func (c *loomServiceClient) Unsubscribe(ctx context.Context, in *UnsubscribeRequest, opts ...grpc.CallOption) (*UnsubscribeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UnsubscribeResponse)
	err := c.cc.Invoke(ctx, LoomService_Unsubscribe_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loomServiceClient) ListTopics(ctx context.Context, in *ListTopicsRequest, opts ...grpc.CallOption) (*ListTopicsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListTopicsResponse)
	err := c.cc.Invoke(ctx, LoomService_ListTopics_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loomServiceClient) GetTopicStats(ctx context.Context, in *GetTopicStatsRequest, opts ...grpc.CallOption) (*TopicStats, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TopicStats)
	err := c.cc.Invoke(ctx, LoomService_GetTopicStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loomServiceClient) SendAsync(ctx context.Context, in *SendAsyncRequest, opts ...grpc.CallOption) (*SendAsyncResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SendAsyncResponse)
	err := c.cc.Invoke(ctx, LoomService_SendAsync_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loomServiceClient) SendAndReceive(ctx context.Context, in *SendAndReceiveRequest, opts ...grpc.CallOption) (*SendAndReceiveResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SendAndReceiveResponse)
	err := c.cc.Invoke(ctx, LoomService_SendAndReceive_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loomServiceClient) PutSharedMemory(ctx context.Context, in *PutSharedMemoryRequest, opts ...grpc.CallOption) (*PutSharedMemoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PutSharedMemoryResponse)
	err := c.cc.Invoke(ctx, LoomService_PutSharedMemory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loomServiceClient) GetSharedMemory(ctx context.Context, in *GetSharedMemoryRequest, opts ...grpc.CallOption) (*GetSharedMemoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSharedMemoryResponse)
	err := c.cc.Invoke(ctx, LoomService_GetSharedMemory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loomServiceClient) DeleteSharedMemory(ctx context.Context, in *DeleteSharedMemoryRequest, opts ...grpc.CallOption) (*DeleteSharedMemoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteSharedMemoryResponse)
	err := c.cc.Invoke(ctx, LoomService_DeleteSharedMemory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loomServiceClient) WatchSharedMemory(ctx context.Context, in *WatchSharedMemoryRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[SharedMemoryValue], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &LoomService_ServiceDesc.Streams[5], LoomService_WatchSharedMemory_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[WatchSharedMemoryRequest, SharedMemoryValue]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type LoomService_WatchSharedMemoryClient = grpc.ServerStreamingClient[SharedMemoryValue]

func (c *loomServiceClient) ListSharedMemoryKeys(ctx context.Context, in *ListSharedMemoryKeysRequest, opts ...grpc.CallOption) (*ListSharedMemoryKeysResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListSharedMemoryKeysResponse)
	err := c.cc.Invoke(ctx, LoomService_ListSharedMemoryKeys_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loomServiceClient) GetSharedMemoryStats(ctx context.Context, in *GetSharedMemoryStatsRequest, opts ...grpc.CallOption) (*SharedMemoryStats, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SharedMemoryStats)
	err := c.cc.Invoke(ctx, LoomService_GetSharedMemoryStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loomServiceClient) ListArtifacts(ctx context.Context, in *ListArtifactsRequest, opts ...grpc.CallOption) (*ListArtifactsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListArtifactsResponse)
	err := c.cc.Invoke(ctx, LoomService_ListArtifacts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loomServiceClient) GetArtifact(ctx context.Context, in *GetArtifactRequest, opts ...grpc.CallOption) (*GetArtifactResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetArtifactResponse)
	err := c.cc.Invoke(ctx, LoomService_GetArtifact_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loomServiceClient) UploadArtifact(ctx context.Context, in *UploadArtifactRequest, opts ...grpc.CallOption) (*UploadArtifactResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UploadArtifactResponse)
	err := c.cc.Invoke(ctx, LoomService_UploadArtifact_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loomServiceClient) DeleteArtifact(ctx context.Context, in *DeleteArtifactRequest, opts ...grpc.CallOption) (*DeleteArtifactResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteArtifactResponse)
	err := c.cc.Invoke(ctx, LoomService_DeleteArtifact_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loomServiceClient) SearchArtifacts(ctx context.Context, in *SearchArtifactsRequest, opts ...grpc.CallOption) (*SearchArtifactsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SearchArtifactsResponse)
	err := c.cc.Invoke(ctx, LoomService_SearchArtifacts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loomServiceClient) GetArtifactContent(ctx context.Context, in *GetArtifactContentRequest, opts ...grpc.CallOption) (*GetArtifactContentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetArtifactContentResponse)
	err := c.cc.Invoke(ctx, LoomService_GetArtifactContent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loomServiceClient) GetArtifactStats(ctx context.Context, in *GetArtifactStatsRequest, opts ...grpc.CallOption) (*GetArtifactStatsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetArtifactStatsResponse)
	err := c.cc.Invoke(ctx, LoomService_GetArtifactStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LoomServiceServer is the server API for LoomService service.
// All implementations must embed UnimplementedLoomServiceServer
// for forward compatibility.
//
// LoomService provides the core agent runtime API for multi-domain
// autonomous LLM agents with pattern-guided learning and self-correction.
type LoomServiceServer interface {
	// Weave executes a user query by selecting patterns, executing tools,
	// and weaving LLM intelligence with domain knowledge.
	Weave(context.Context, *WeaveRequest) (*WeaveResponse, error)
	// StreamWeave executes a query and streams incremental progress updates.
	StreamWeave(*WeaveRequest, grpc.ServerStreamingServer[WeaveProgress]) error
	// LoadPatterns loads pattern definitions from a directory or repository.
	LoadPatterns(context.Context, *LoadPatternsRequest) (*LoadPatternsResponse, error)
	// ListPatterns retrieves available patterns with optional filtering.
	ListPatterns(context.Context, *ListPatternsRequest) (*ListPatternsResponse, error)
	// GetPattern retrieves a specific pattern by name.
	GetPattern(context.Context, *GetPatternRequest) (*Pattern, error)
	// CreatePattern creates a new pattern at runtime.
	CreatePattern(context.Context, *CreatePatternRequest) (*CreatePatternResponse, error)
	// StreamPatternUpdates streams real-time pattern updates (additions, changes, deletions).
	// Used by TUI and other clients to show live pattern library changes.
	StreamPatternUpdates(*StreamPatternUpdatesRequest, grpc.ServerStreamingServer[PatternUpdateEvent]) error
	// AnswerClarificationQuestion provides an answer to a clarification question asked by an agent.
	// Used by TUI and other clients to respond to EventQuestionAsked progress events.
	AnswerClarificationQuestion(context.Context, *AnswerClarificationRequest) (*AnswerClarificationResponse, error)
	// CreateSession creates a new conversation session.
	CreateSession(context.Context, *CreateSessionRequest) (*Session, error)
	// GetSession retrieves session details.
	GetSession(context.Context, *GetSessionRequest) (*Session, error)
	// ListSessions lists all sessions with optional filtering.
	ListSessions(context.Context, *ListSessionsRequest) (*ListSessionsResponse, error)
	// DeleteSession deletes a session and its history.
	DeleteSession(context.Context, *DeleteSessionRequest) (*DeleteSessionResponse, error)
	// SubscribeToSession subscribes to real-time updates for a session.
	// Returns a stream of updates when new messages arrive or session state changes.
	// This allows clients to receive asynchronous responses from workflow coordinators
	// and sub-agents without polling.
	SubscribeToSession(*SubscribeToSessionRequest, grpc.ServerStreamingServer[SessionUpdate]) error
	// GetConversationHistory retrieves conversation history for a session.
	GetConversationHistory(context.Context, *GetConversationHistoryRequest) (*ConversationHistory, error)
	// RegisterTool dynamically registers a new tool.
	RegisterTool(context.Context, *RegisterToolRequest) (*RegisterToolResponse, error)
	// ListTools lists all registered tools.
	ListTools(context.Context, *ListToolsRequest) (*ListToolsResponse, error)
	// GetTrace retrieves execution trace for observability.
	GetTrace(context.Context, *GetTraceRequest) (*Trace, error)
	// GetHealth returns health status of the agent.
	GetHealth(context.Context, *GetHealthRequest) (*HealthStatus, error)
	// GetServerConfig retrieves the current server configuration.
	GetServerConfig(context.Context, *GetServerConfigRequest) (*ServerConfig, error)
	// GetTLSStatus retrieves the current TLS/certificate status.
	GetTLSStatus(context.Context, *GetTLSStatusRequest) (*TLSStatus, error)
	// RenewCertificate manually triggers certificate renewal (for Let's Encrypt).
	RenewCertificate(context.Context, *RenewCertificateRequest) (*RenewCertificateResponse, error)
	// CreateAgentFromConfig creates an agent from configuration.
	CreateAgentFromConfig(context.Context, *CreateAgentRequest) (*AgentInfo, error)
	// ListAgents lists all registered agents.
	ListAgents(context.Context, *ListAgentsRequest) (*ListAgentsResponse, error)
	// GetAgent retrieves agent information.
	GetAgent(context.Context, *GetAgentRequest) (*AgentInfo, error)
	// StartAgent starts a stopped agent.
	StartAgent(context.Context, *StartAgentRequest) (*AgentInfo, error)
	// StopAgent stops a running agent.
	StopAgent(context.Context, *StopAgentRequest) (*AgentInfo, error)
	// DeleteAgent deletes an agent.
	DeleteAgent(context.Context, *DeleteAgentRequest) (*DeleteAgentResponse, error)
	// ReloadAgent hot-reloads agent configuration without stopping.
	ReloadAgent(context.Context, *ReloadAgentRequest) (*AgentInfo, error)
	// SwitchModel switches the LLM model/provider for a session without losing context.
	SwitchModel(context.Context, *SwitchModelRequest) (*SwitchModelResponse, error)
	// ListAvailableModels lists all available LLM models/providers.
	ListAvailableModels(context.Context, *ListAvailableModelsRequest) (*ListAvailableModelsResponse, error)
	// RequestToolPermission requests user permission to execute a tool.
	RequestToolPermission(context.Context, *ToolPermissionRequest) (*ToolPermissionResponse, error)
	// ListMCPServers lists all configured MCP servers.
	ListMCPServers(context.Context, *ListMCPServersRequest) (*ListMCPServersResponse, error)
	// GetMCPServer retrieves a specific MCP server configuration.
	GetMCPServer(context.Context, *GetMCPServerRequest) (*MCPServerInfo, error)
	// AddMCPServer adds a new MCP server configuration.
	AddMCPServer(context.Context, *AddMCPServerRequest) (*AddMCPServerResponse, error)
	// UpdateMCPServer updates an existing MCP server configuration.
	UpdateMCPServer(context.Context, *UpdateMCPServerRequest) (*MCPServerInfo, error)
	// DeleteMCPServer removes an MCP server configuration.
	DeleteMCPServer(context.Context, *DeleteMCPServerRequest) (*DeleteMCPServerResponse, error)
	// RestartMCPServer restarts a running MCP server.
	RestartMCPServer(context.Context, *RestartMCPServerRequest) (*MCPServerInfo, error)
	// HealthCheckMCPServers checks health of all MCP servers.
	HealthCheckMCPServers(context.Context, *HealthCheckMCPServersRequest) (*HealthCheckMCPServersResponse, error)
	// TestMCPServerConnection tests an MCP server configuration without persisting it.
	// This allows users to validate their configuration (command, args, env vars) before saving.
	TestMCPServerConnection(context.Context, *TestMCPServerConnectionRequest) (*TestMCPServerConnectionResponse, error)
	// ListMCPServerTools lists all tools from a specific MCP server.
	// This queries the MCP server directly through the manager, not the agent's tool registry.
	ListMCPServerTools(context.Context, *ListMCPServerToolsRequest) (*ListMCPServerToolsResponse, error)
	// ExecuteWorkflow executes a multi-agent workflow pattern.
	ExecuteWorkflow(context.Context, *ExecuteWorkflowRequest) (*ExecuteWorkflowResponse, error)
	// StreamWorkflow executes a workflow and streams progress updates.
	StreamWorkflow(*ExecuteWorkflowRequest, grpc.ServerStreamingServer[WorkflowProgress]) error
	// GetWorkflowExecution retrieves a workflow execution.
	GetWorkflowExecution(context.Context, *GetWorkflowExecutionRequest) (*WorkflowExecution, error)
	// ListWorkflowExecutions lists workflow executions.
	ListWorkflowExecutions(context.Context, *ListWorkflowExecutionsRequest) (*ListWorkflowExecutionsResponse, error)
	// ScheduleWorkflow creates a new scheduled workflow.
	ScheduleWorkflow(context.Context, *ScheduleWorkflowRequest) (*ScheduleWorkflowResponse, error)
	// UpdateScheduledWorkflow updates an existing scheduled workflow.
	UpdateScheduledWorkflow(context.Context, *UpdateScheduledWorkflowRequest) (*ScheduleWorkflowResponse, error)
	// GetScheduledWorkflow retrieves a scheduled workflow by ID.
	GetScheduledWorkflow(context.Context, *GetScheduledWorkflowRequest) (*ScheduledWorkflow, error)
	// ListScheduledWorkflows lists all scheduled workflows.
	ListScheduledWorkflows(context.Context, *ListScheduledWorkflowsRequest) (*ListScheduledWorkflowsResponse, error)
	// DeleteScheduledWorkflow deletes a scheduled workflow.
	DeleteScheduledWorkflow(context.Context, *DeleteScheduledWorkflowRequest) (*emptypb.Empty, error)
	// TriggerScheduledWorkflow manually triggers a scheduled workflow immediately.
	TriggerScheduledWorkflow(context.Context, *TriggerScheduledWorkflowRequest) (*ExecuteWorkflowResponse, error)
	// PauseSchedule pauses a schedule without deleting it.
	PauseSchedule(context.Context, *PauseScheduleRequest) (*emptypb.Empty, error)
	// ResumeSchedule resumes a paused schedule.
	ResumeSchedule(context.Context, *ResumeScheduleRequest) (*emptypb.Empty, error)
	// GetScheduleHistory retrieves execution history for a schedule.
	GetScheduleHistory(context.Context, *GetScheduleHistoryRequest) (*GetScheduleHistoryResponse, error)
	// Publish publishes a message to a topic (one-to-many broadcast).
	Publish(context.Context, *PublishRequest) (*PublishResponse, error)
	// Subscribe subscribes to a topic and receives messages via stream.
	Subscribe(*SubscribeRequest, grpc.ServerStreamingServer[BusMessage]) error
	// Unsubscribe cancels a topic subscription.
	Unsubscribe(context.Context, *UnsubscribeRequest) (*UnsubscribeResponse, error)
	// ListTopics lists all active topics.
	ListTopics(context.Context, *ListTopicsRequest) (*ListTopicsResponse, error)
	// GetTopicStats retrieves statistics for a topic.
	GetTopicStats(context.Context, *GetTopicStatsRequest) (*TopicStats, error)
	// SendAsync sends a message asynchronously (fire-and-forget).
	SendAsync(context.Context, *SendAsyncRequest) (*SendAsyncResponse, error)
	// SendAndReceive sends a message and waits for response (RPC-style).
	SendAndReceive(context.Context, *SendAndReceiveRequest) (*SendAndReceiveResponse, error)
	// PutSharedMemory writes or updates a value in shared memory.
	PutSharedMemory(context.Context, *PutSharedMemoryRequest) (*PutSharedMemoryResponse, error)
	// GetSharedMemory reads a value from shared memory.
	GetSharedMemory(context.Context, *GetSharedMemoryRequest) (*GetSharedMemoryResponse, error)
	// DeleteSharedMemory removes a value from shared memory.
	DeleteSharedMemory(context.Context, *DeleteSharedMemoryRequest) (*DeleteSharedMemoryResponse, error)
	// WatchSharedMemory watches for changes to keys in a namespace.
	WatchSharedMemory(*WatchSharedMemoryRequest, grpc.ServerStreamingServer[SharedMemoryValue]) error
	// ListSharedMemoryKeys lists all keys in a namespace.
	ListSharedMemoryKeys(context.Context, *ListSharedMemoryKeysRequest) (*ListSharedMemoryKeysResponse, error)
	// GetSharedMemoryStats retrieves statistics for a namespace.
	GetSharedMemoryStats(context.Context, *GetSharedMemoryStatsRequest) (*SharedMemoryStats, error)
	// ListArtifacts lists artifacts with optional filtering.
	ListArtifacts(context.Context, *ListArtifactsRequest) (*ListArtifactsResponse, error)
	// GetArtifact retrieves artifact metadata.
	GetArtifact(context.Context, *GetArtifactRequest) (*GetArtifactResponse, error)
	// UploadArtifact uploads a file to artifacts storage.
	UploadArtifact(context.Context, *UploadArtifactRequest) (*UploadArtifactResponse, error)
	// DeleteArtifact deletes an artifact (soft or hard delete).
	DeleteArtifact(context.Context, *DeleteArtifactRequest) (*DeleteArtifactResponse, error)
	// SearchArtifacts performs full-text search on artifacts.
	SearchArtifacts(context.Context, *SearchArtifactsRequest) (*SearchArtifactsResponse, error)
	// GetArtifactContent reads artifact file content.
	GetArtifactContent(context.Context, *GetArtifactContentRequest) (*GetArtifactContentResponse, error)
	// GetArtifactStats retrieves storage statistics.
	GetArtifactStats(context.Context, *GetArtifactStatsRequest) (*GetArtifactStatsResponse, error)
	mustEmbedUnimplementedLoomServiceServer()
}

// UnimplementedLoomServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedLoomServiceServer struct{}

func (UnimplementedLoomServiceServer) Weave(context.Context, *WeaveRequest) (*WeaveResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Weave not implemented")
}
func (UnimplementedLoomServiceServer) StreamWeave(*WeaveRequest, grpc.ServerStreamingServer[WeaveProgress]) error {
	return status.Error(codes.Unimplemented, "method StreamWeave not implemented")
}
func (UnimplementedLoomServiceServer) LoadPatterns(context.Context, *LoadPatternsRequest) (*LoadPatternsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method LoadPatterns not implemented")
}
func (UnimplementedLoomServiceServer) ListPatterns(context.Context, *ListPatternsRequest) (*ListPatternsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListPatterns not implemented")
}
func (UnimplementedLoomServiceServer) GetPattern(context.Context, *GetPatternRequest) (*Pattern, error) {
	return nil, status.Error(codes.Unimplemented, "method GetPattern not implemented")
}
func (UnimplementedLoomServiceServer) CreatePattern(context.Context, *CreatePatternRequest) (*CreatePatternResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreatePattern not implemented")
}
func (UnimplementedLoomServiceServer) StreamPatternUpdates(*StreamPatternUpdatesRequest, grpc.ServerStreamingServer[PatternUpdateEvent]) error {
	return status.Error(codes.Unimplemented, "method StreamPatternUpdates not implemented")
}
func (UnimplementedLoomServiceServer) AnswerClarificationQuestion(context.Context, *AnswerClarificationRequest) (*AnswerClarificationResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method AnswerClarificationQuestion not implemented")
}
func (UnimplementedLoomServiceServer) CreateSession(context.Context, *CreateSessionRequest) (*Session, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateSession not implemented")
}
func (UnimplementedLoomServiceServer) GetSession(context.Context, *GetSessionRequest) (*Session, error) {
	return nil, status.Error(codes.Unimplemented, "method GetSession not implemented")
}
func (UnimplementedLoomServiceServer) ListSessions(context.Context, *ListSessionsRequest) (*ListSessionsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListSessions not implemented")
}
func (UnimplementedLoomServiceServer) DeleteSession(context.Context, *DeleteSessionRequest) (*DeleteSessionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteSession not implemented")
}
func (UnimplementedLoomServiceServer) SubscribeToSession(*SubscribeToSessionRequest, grpc.ServerStreamingServer[SessionUpdate]) error {
	return status.Error(codes.Unimplemented, "method SubscribeToSession not implemented")
}
func (UnimplementedLoomServiceServer) GetConversationHistory(context.Context, *GetConversationHistoryRequest) (*ConversationHistory, error) {
	return nil, status.Error(codes.Unimplemented, "method GetConversationHistory not implemented")
}
func (UnimplementedLoomServiceServer) RegisterTool(context.Context, *RegisterToolRequest) (*RegisterToolResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RegisterTool not implemented")
}
func (UnimplementedLoomServiceServer) ListTools(context.Context, *ListToolsRequest) (*ListToolsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListTools not implemented")
}
func (UnimplementedLoomServiceServer) GetTrace(context.Context, *GetTraceRequest) (*Trace, error) {
	return nil, status.Error(codes.Unimplemented, "method GetTrace not implemented")
}
func (UnimplementedLoomServiceServer) GetHealth(context.Context, *GetHealthRequest) (*HealthStatus, error) {
	return nil, status.Error(codes.Unimplemented, "method GetHealth not implemented")
}
func (UnimplementedLoomServiceServer) GetServerConfig(context.Context, *GetServerConfigRequest) (*ServerConfig, error) {
	return nil, status.Error(codes.Unimplemented, "method GetServerConfig not implemented")
}
func (UnimplementedLoomServiceServer) GetTLSStatus(context.Context, *GetTLSStatusRequest) (*TLSStatus, error) {
	return nil, status.Error(codes.Unimplemented, "method GetTLSStatus not implemented")
}
func (UnimplementedLoomServiceServer) RenewCertificate(context.Context, *RenewCertificateRequest) (*RenewCertificateResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RenewCertificate not implemented")
}
func (UnimplementedLoomServiceServer) CreateAgentFromConfig(context.Context, *CreateAgentRequest) (*AgentInfo, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateAgentFromConfig not implemented")
}
func (UnimplementedLoomServiceServer) ListAgents(context.Context, *ListAgentsRequest) (*ListAgentsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListAgents not implemented")
}
func (UnimplementedLoomServiceServer) GetAgent(context.Context, *GetAgentRequest) (*AgentInfo, error) {
	return nil, status.Error(codes.Unimplemented, "method GetAgent not implemented")
}
func (UnimplementedLoomServiceServer) StartAgent(context.Context, *StartAgentRequest) (*AgentInfo, error) {
	return nil, status.Error(codes.Unimplemented, "method StartAgent not implemented")
}
func (UnimplementedLoomServiceServer) StopAgent(context.Context, *StopAgentRequest) (*AgentInfo, error) {
	return nil, status.Error(codes.Unimplemented, "method StopAgent not implemented")
}
func (UnimplementedLoomServiceServer) DeleteAgent(context.Context, *DeleteAgentRequest) (*DeleteAgentResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteAgent not implemented")
}
func (UnimplementedLoomServiceServer) ReloadAgent(context.Context, *ReloadAgentRequest) (*AgentInfo, error) {
	return nil, status.Error(codes.Unimplemented, "method ReloadAgent not implemented")
}
func (UnimplementedLoomServiceServer) SwitchModel(context.Context, *SwitchModelRequest) (*SwitchModelResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SwitchModel not implemented")
}
func (UnimplementedLoomServiceServer) ListAvailableModels(context.Context, *ListAvailableModelsRequest) (*ListAvailableModelsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListAvailableModels not implemented")
}
func (UnimplementedLoomServiceServer) RequestToolPermission(context.Context, *ToolPermissionRequest) (*ToolPermissionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RequestToolPermission not implemented")
}
func (UnimplementedLoomServiceServer) ListMCPServers(context.Context, *ListMCPServersRequest) (*ListMCPServersResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListMCPServers not implemented")
}
func (UnimplementedLoomServiceServer) GetMCPServer(context.Context, *GetMCPServerRequest) (*MCPServerInfo, error) {
	return nil, status.Error(codes.Unimplemented, "method GetMCPServer not implemented")
}
func (UnimplementedLoomServiceServer) AddMCPServer(context.Context, *AddMCPServerRequest) (*AddMCPServerResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method AddMCPServer not implemented")
}
func (UnimplementedLoomServiceServer) UpdateMCPServer(context.Context, *UpdateMCPServerRequest) (*MCPServerInfo, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateMCPServer not implemented")
}
func (UnimplementedLoomServiceServer) DeleteMCPServer(context.Context, *DeleteMCPServerRequest) (*DeleteMCPServerResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteMCPServer not implemented")
}
func (UnimplementedLoomServiceServer) RestartMCPServer(context.Context, *RestartMCPServerRequest) (*MCPServerInfo, error) {
	return nil, status.Error(codes.Unimplemented, "method RestartMCPServer not implemented")
}
func (UnimplementedLoomServiceServer) HealthCheckMCPServers(context.Context, *HealthCheckMCPServersRequest) (*HealthCheckMCPServersResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method HealthCheckMCPServers not implemented")
}
func (UnimplementedLoomServiceServer) TestMCPServerConnection(context.Context, *TestMCPServerConnectionRequest) (*TestMCPServerConnectionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method TestMCPServerConnection not implemented")
}
func (UnimplementedLoomServiceServer) ListMCPServerTools(context.Context, *ListMCPServerToolsRequest) (*ListMCPServerToolsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListMCPServerTools not implemented")
}
func (UnimplementedLoomServiceServer) ExecuteWorkflow(context.Context, *ExecuteWorkflowRequest) (*ExecuteWorkflowResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ExecuteWorkflow not implemented")
}
func (UnimplementedLoomServiceServer) StreamWorkflow(*ExecuteWorkflowRequest, grpc.ServerStreamingServer[WorkflowProgress]) error {
	return status.Error(codes.Unimplemented, "method StreamWorkflow not implemented")
}
func (UnimplementedLoomServiceServer) GetWorkflowExecution(context.Context, *GetWorkflowExecutionRequest) (*WorkflowExecution, error) {
	return nil, status.Error(codes.Unimplemented, "method GetWorkflowExecution not implemented")
}
func (UnimplementedLoomServiceServer) ListWorkflowExecutions(context.Context, *ListWorkflowExecutionsRequest) (*ListWorkflowExecutionsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListWorkflowExecutions not implemented")
}
func (UnimplementedLoomServiceServer) ScheduleWorkflow(context.Context, *ScheduleWorkflowRequest) (*ScheduleWorkflowResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ScheduleWorkflow not implemented")
}
func (UnimplementedLoomServiceServer) UpdateScheduledWorkflow(context.Context, *UpdateScheduledWorkflowRequest) (*ScheduleWorkflowResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateScheduledWorkflow not implemented")
}
func (UnimplementedLoomServiceServer) GetScheduledWorkflow(context.Context, *GetScheduledWorkflowRequest) (*ScheduledWorkflow, error) {
	return nil, status.Error(codes.Unimplemented, "method GetScheduledWorkflow not implemented")
}
func (UnimplementedLoomServiceServer) ListScheduledWorkflows(context.Context, *ListScheduledWorkflowsRequest) (*ListScheduledWorkflowsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListScheduledWorkflows not implemented")
}
func (UnimplementedLoomServiceServer) DeleteScheduledWorkflow(context.Context, *DeleteScheduledWorkflowRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteScheduledWorkflow not implemented")
}
func (UnimplementedLoomServiceServer) TriggerScheduledWorkflow(context.Context, *TriggerScheduledWorkflowRequest) (*ExecuteWorkflowResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method TriggerScheduledWorkflow not implemented")
}
func (UnimplementedLoomServiceServer) PauseSchedule(context.Context, *PauseScheduleRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method PauseSchedule not implemented")
}
func (UnimplementedLoomServiceServer) ResumeSchedule(context.Context, *ResumeScheduleRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method ResumeSchedule not implemented")
}
func (UnimplementedLoomServiceServer) GetScheduleHistory(context.Context, *GetScheduleHistoryRequest) (*GetScheduleHistoryResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetScheduleHistory not implemented")
}
func (UnimplementedLoomServiceServer) Publish(context.Context, *PublishRequest) (*PublishResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Publish not implemented")
}
func (UnimplementedLoomServiceServer) Subscribe(*SubscribeRequest, grpc.ServerStreamingServer[BusMessage]) error {
	return status.Error(codes.Unimplemented, "method Subscribe not implemented")
}
func (UnimplementedLoomServiceServer) Unsubscribe(context.Context, *UnsubscribeRequest) (*UnsubscribeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Unsubscribe not implemented")
}
func (UnimplementedLoomServiceServer) ListTopics(context.Context, *ListTopicsRequest) (*ListTopicsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListTopics not implemented")
}
func (UnimplementedLoomServiceServer) GetTopicStats(context.Context, *GetTopicStatsRequest) (*TopicStats, error) {
	return nil, status.Error(codes.Unimplemented, "method GetTopicStats not implemented")
}
func (UnimplementedLoomServiceServer) SendAsync(context.Context, *SendAsyncRequest) (*SendAsyncResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SendAsync not implemented")
}
func (UnimplementedLoomServiceServer) SendAndReceive(context.Context, *SendAndReceiveRequest) (*SendAndReceiveResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SendAndReceive not implemented")
}
func (UnimplementedLoomServiceServer) PutSharedMemory(context.Context, *PutSharedMemoryRequest) (*PutSharedMemoryResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method PutSharedMemory not implemented")
}
func (UnimplementedLoomServiceServer) GetSharedMemory(context.Context, *GetSharedMemoryRequest) (*GetSharedMemoryResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetSharedMemory not implemented")
}
func (UnimplementedLoomServiceServer) DeleteSharedMemory(context.Context, *DeleteSharedMemoryRequest) (*DeleteSharedMemoryResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteSharedMemory not implemented")
}
func (UnimplementedLoomServiceServer) WatchSharedMemory(*WatchSharedMemoryRequest, grpc.ServerStreamingServer[SharedMemoryValue]) error {
	return status.Error(codes.Unimplemented, "method WatchSharedMemory not implemented")
}
func (UnimplementedLoomServiceServer) ListSharedMemoryKeys(context.Context, *ListSharedMemoryKeysRequest) (*ListSharedMemoryKeysResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListSharedMemoryKeys not implemented")
}
func (UnimplementedLoomServiceServer) GetSharedMemoryStats(context.Context, *GetSharedMemoryStatsRequest) (*SharedMemoryStats, error) {
	return nil, status.Error(codes.Unimplemented, "method GetSharedMemoryStats not implemented")
}
func (UnimplementedLoomServiceServer) ListArtifacts(context.Context, *ListArtifactsRequest) (*ListArtifactsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListArtifacts not implemented")
}
func (UnimplementedLoomServiceServer) GetArtifact(context.Context, *GetArtifactRequest) (*GetArtifactResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetArtifact not implemented")
}
func (UnimplementedLoomServiceServer) UploadArtifact(context.Context, *UploadArtifactRequest) (*UploadArtifactResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UploadArtifact not implemented")
}
func (UnimplementedLoomServiceServer) DeleteArtifact(context.Context, *DeleteArtifactRequest) (*DeleteArtifactResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteArtifact not implemented")
}
func (UnimplementedLoomServiceServer) SearchArtifacts(context.Context, *SearchArtifactsRequest) (*SearchArtifactsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SearchArtifacts not implemented")
}
func (UnimplementedLoomServiceServer) GetArtifactContent(context.Context, *GetArtifactContentRequest) (*GetArtifactContentResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetArtifactContent not implemented")
}
func (UnimplementedLoomServiceServer) GetArtifactStats(context.Context, *GetArtifactStatsRequest) (*GetArtifactStatsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetArtifactStats not implemented")
}
func (UnimplementedLoomServiceServer) mustEmbedUnimplementedLoomServiceServer() {}
func (UnimplementedLoomServiceServer) testEmbeddedByValue()                     {}

// UnsafeLoomServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LoomServiceServer will
// result in compilation errors.
type UnsafeLoomServiceServer interface {
	mustEmbedUnimplementedLoomServiceServer()
}

func RegisterLoomServiceServer(s grpc.ServiceRegistrar, srv LoomServiceServer) {
	// If the following call panics, it indicates UnimplementedLoomServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&LoomService_ServiceDesc, srv)
}

func _LoomService_Weave_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WeaveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoomServiceServer).Weave(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoomService_Weave_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoomServiceServer).Weave(ctx, req.(*WeaveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoomService_StreamWeave_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WeaveRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LoomServiceServer).StreamWeave(m, &grpc.GenericServerStream[WeaveRequest, WeaveProgress]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type LoomService_StreamWeaveServer = grpc.ServerStreamingServer[WeaveProgress]

func _LoomService_LoadPatterns_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoadPatternsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoomServiceServer).LoadPatterns(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoomService_LoadPatterns_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoomServiceServer).LoadPatterns(ctx, req.(*LoadPatternsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoomService_ListPatterns_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPatternsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoomServiceServer).ListPatterns(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoomService_ListPatterns_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoomServiceServer).ListPatterns(ctx, req.(*ListPatternsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoomService_GetPattern_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPatternRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoomServiceServer).GetPattern(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoomService_GetPattern_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoomServiceServer).GetPattern(ctx, req.(*GetPatternRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoomService_CreatePattern_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreatePatternRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoomServiceServer).CreatePattern(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoomService_CreatePattern_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoomServiceServer).CreatePattern(ctx, req.(*CreatePatternRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoomService_StreamPatternUpdates_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamPatternUpdatesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LoomServiceServer).StreamPatternUpdates(m, &grpc.GenericServerStream[StreamPatternUpdatesRequest, PatternUpdateEvent]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type LoomService_StreamPatternUpdatesServer = grpc.ServerStreamingServer[PatternUpdateEvent]

func _LoomService_AnswerClarificationQuestion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AnswerClarificationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoomServiceServer).AnswerClarificationQuestion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoomService_AnswerClarificationQuestion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoomServiceServer).AnswerClarificationQuestion(ctx, req.(*AnswerClarificationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoomService_CreateSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoomServiceServer).CreateSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoomService_CreateSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoomServiceServer).CreateSession(ctx, req.(*CreateSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoomService_GetSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoomServiceServer).GetSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoomService_GetSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoomServiceServer).GetSession(ctx, req.(*GetSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoomService_ListSessions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListSessionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoomServiceServer).ListSessions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoomService_ListSessions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoomServiceServer).ListSessions(ctx, req.(*ListSessionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoomService_DeleteSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoomServiceServer).DeleteSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoomService_DeleteSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoomServiceServer).DeleteSession(ctx, req.(*DeleteSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoomService_SubscribeToSession_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeToSessionRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LoomServiceServer).SubscribeToSession(m, &grpc.GenericServerStream[SubscribeToSessionRequest, SessionUpdate]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type LoomService_SubscribeToSessionServer = grpc.ServerStreamingServer[SessionUpdate]

func _LoomService_GetConversationHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetConversationHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoomServiceServer).GetConversationHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoomService_GetConversationHistory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoomServiceServer).GetConversationHistory(ctx, req.(*GetConversationHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoomService_RegisterTool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterToolRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoomServiceServer).RegisterTool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoomService_RegisterTool_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoomServiceServer).RegisterTool(ctx, req.(*RegisterToolRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoomService_ListTools_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListToolsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoomServiceServer).ListTools(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoomService_ListTools_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoomServiceServer).ListTools(ctx, req.(*ListToolsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoomService_GetTrace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTraceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoomServiceServer).GetTrace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoomService_GetTrace_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoomServiceServer).GetTrace(ctx, req.(*GetTraceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoomService_GetHealth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetHealthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoomServiceServer).GetHealth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoomService_GetHealth_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoomServiceServer).GetHealth(ctx, req.(*GetHealthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoomService_GetServerConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetServerConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoomServiceServer).GetServerConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoomService_GetServerConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoomServiceServer).GetServerConfig(ctx, req.(*GetServerConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoomService_GetTLSStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTLSStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoomServiceServer).GetTLSStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoomService_GetTLSStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoomServiceServer).GetTLSStatus(ctx, req.(*GetTLSStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoomService_RenewCertificate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RenewCertificateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoomServiceServer).RenewCertificate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoomService_RenewCertificate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoomServiceServer).RenewCertificate(ctx, req.(*RenewCertificateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoomService_CreateAgentFromConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateAgentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoomServiceServer).CreateAgentFromConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoomService_CreateAgentFromConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoomServiceServer).CreateAgentFromConfig(ctx, req.(*CreateAgentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoomService_ListAgents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAgentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoomServiceServer).ListAgents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoomService_ListAgents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoomServiceServer).ListAgents(ctx, req.(*ListAgentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoomService_GetAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAgentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoomServiceServer).GetAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoomService_GetAgent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoomServiceServer).GetAgent(ctx, req.(*GetAgentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoomService_StartAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartAgentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoomServiceServer).StartAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoomService_StartAgent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoomServiceServer).StartAgent(ctx, req.(*StartAgentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoomService_StopAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopAgentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoomServiceServer).StopAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoomService_StopAgent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoomServiceServer).StopAgent(ctx, req.(*StopAgentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoomService_DeleteAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteAgentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoomServiceServer).DeleteAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoomService_DeleteAgent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoomServiceServer).DeleteAgent(ctx, req.(*DeleteAgentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoomService_ReloadAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReloadAgentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoomServiceServer).ReloadAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoomService_ReloadAgent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoomServiceServer).ReloadAgent(ctx, req.(*ReloadAgentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoomService_SwitchModel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SwitchModelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoomServiceServer).SwitchModel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoomService_SwitchModel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoomServiceServer).SwitchModel(ctx, req.(*SwitchModelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoomService_ListAvailableModels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAvailableModelsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoomServiceServer).ListAvailableModels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoomService_ListAvailableModels_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoomServiceServer).ListAvailableModels(ctx, req.(*ListAvailableModelsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoomService_RequestToolPermission_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ToolPermissionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoomServiceServer).RequestToolPermission(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoomService_RequestToolPermission_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoomServiceServer).RequestToolPermission(ctx, req.(*ToolPermissionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoomService_ListMCPServers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListMCPServersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoomServiceServer).ListMCPServers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoomService_ListMCPServers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoomServiceServer).ListMCPServers(ctx, req.(*ListMCPServersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoomService_GetMCPServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMCPServerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoomServiceServer).GetMCPServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoomService_GetMCPServer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoomServiceServer).GetMCPServer(ctx, req.(*GetMCPServerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoomService_AddMCPServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddMCPServerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoomServiceServer).AddMCPServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoomService_AddMCPServer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoomServiceServer).AddMCPServer(ctx, req.(*AddMCPServerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoomService_UpdateMCPServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateMCPServerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoomServiceServer).UpdateMCPServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoomService_UpdateMCPServer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoomServiceServer).UpdateMCPServer(ctx, req.(*UpdateMCPServerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoomService_DeleteMCPServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteMCPServerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoomServiceServer).DeleteMCPServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoomService_DeleteMCPServer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoomServiceServer).DeleteMCPServer(ctx, req.(*DeleteMCPServerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoomService_RestartMCPServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RestartMCPServerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoomServiceServer).RestartMCPServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoomService_RestartMCPServer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoomServiceServer).RestartMCPServer(ctx, req.(*RestartMCPServerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoomService_HealthCheckMCPServers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HealthCheckMCPServersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoomServiceServer).HealthCheckMCPServers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoomService_HealthCheckMCPServers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoomServiceServer).HealthCheckMCPServers(ctx, req.(*HealthCheckMCPServersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoomService_TestMCPServerConnection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestMCPServerConnectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoomServiceServer).TestMCPServerConnection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoomService_TestMCPServerConnection_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoomServiceServer).TestMCPServerConnection(ctx, req.(*TestMCPServerConnectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoomService_ListMCPServerTools_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListMCPServerToolsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoomServiceServer).ListMCPServerTools(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoomService_ListMCPServerTools_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoomServiceServer).ListMCPServerTools(ctx, req.(*ListMCPServerToolsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoomService_ExecuteWorkflow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecuteWorkflowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoomServiceServer).ExecuteWorkflow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoomService_ExecuteWorkflow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoomServiceServer).ExecuteWorkflow(ctx, req.(*ExecuteWorkflowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoomService_StreamWorkflow_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ExecuteWorkflowRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LoomServiceServer).StreamWorkflow(m, &grpc.GenericServerStream[ExecuteWorkflowRequest, WorkflowProgress]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type LoomService_StreamWorkflowServer = grpc.ServerStreamingServer[WorkflowProgress]

func _LoomService_GetWorkflowExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetWorkflowExecutionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoomServiceServer).GetWorkflowExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoomService_GetWorkflowExecution_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoomServiceServer).GetWorkflowExecution(ctx, req.(*GetWorkflowExecutionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoomService_ListWorkflowExecutions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListWorkflowExecutionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoomServiceServer).ListWorkflowExecutions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoomService_ListWorkflowExecutions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoomServiceServer).ListWorkflowExecutions(ctx, req.(*ListWorkflowExecutionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoomService_ScheduleWorkflow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScheduleWorkflowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoomServiceServer).ScheduleWorkflow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoomService_ScheduleWorkflow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoomServiceServer).ScheduleWorkflow(ctx, req.(*ScheduleWorkflowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoomService_UpdateScheduledWorkflow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateScheduledWorkflowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoomServiceServer).UpdateScheduledWorkflow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoomService_UpdateScheduledWorkflow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoomServiceServer).UpdateScheduledWorkflow(ctx, req.(*UpdateScheduledWorkflowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoomService_GetScheduledWorkflow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetScheduledWorkflowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoomServiceServer).GetScheduledWorkflow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoomService_GetScheduledWorkflow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoomServiceServer).GetScheduledWorkflow(ctx, req.(*GetScheduledWorkflowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoomService_ListScheduledWorkflows_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListScheduledWorkflowsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoomServiceServer).ListScheduledWorkflows(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoomService_ListScheduledWorkflows_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoomServiceServer).ListScheduledWorkflows(ctx, req.(*ListScheduledWorkflowsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoomService_DeleteScheduledWorkflow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteScheduledWorkflowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoomServiceServer).DeleteScheduledWorkflow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoomService_DeleteScheduledWorkflow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoomServiceServer).DeleteScheduledWorkflow(ctx, req.(*DeleteScheduledWorkflowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoomService_TriggerScheduledWorkflow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TriggerScheduledWorkflowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoomServiceServer).TriggerScheduledWorkflow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoomService_TriggerScheduledWorkflow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoomServiceServer).TriggerScheduledWorkflow(ctx, req.(*TriggerScheduledWorkflowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoomService_PauseSchedule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PauseScheduleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoomServiceServer).PauseSchedule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoomService_PauseSchedule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoomServiceServer).PauseSchedule(ctx, req.(*PauseScheduleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoomService_ResumeSchedule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResumeScheduleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoomServiceServer).ResumeSchedule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoomService_ResumeSchedule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoomServiceServer).ResumeSchedule(ctx, req.(*ResumeScheduleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoomService_GetScheduleHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetScheduleHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoomServiceServer).GetScheduleHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoomService_GetScheduleHistory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoomServiceServer).GetScheduleHistory(ctx, req.(*GetScheduleHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoomService_Publish_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublishRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoomServiceServer).Publish(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoomService_Publish_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoomServiceServer).Publish(ctx, req.(*PublishRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoomService_Subscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LoomServiceServer).Subscribe(m, &grpc.GenericServerStream[SubscribeRequest, BusMessage]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type LoomService_SubscribeServer = grpc.ServerStreamingServer[BusMessage]

func _LoomService_Unsubscribe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnsubscribeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoomServiceServer).Unsubscribe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoomService_Unsubscribe_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoomServiceServer).Unsubscribe(ctx, req.(*UnsubscribeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoomService_ListTopics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTopicsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoomServiceServer).ListTopics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoomService_ListTopics_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoomServiceServer).ListTopics(ctx, req.(*ListTopicsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoomService_GetTopicStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTopicStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoomServiceServer).GetTopicStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoomService_GetTopicStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoomServiceServer).GetTopicStats(ctx, req.(*GetTopicStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoomService_SendAsync_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendAsyncRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoomServiceServer).SendAsync(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoomService_SendAsync_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoomServiceServer).SendAsync(ctx, req.(*SendAsyncRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoomService_SendAndReceive_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendAndReceiveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoomServiceServer).SendAndReceive(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoomService_SendAndReceive_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoomServiceServer).SendAndReceive(ctx, req.(*SendAndReceiveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoomService_PutSharedMemory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PutSharedMemoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoomServiceServer).PutSharedMemory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoomService_PutSharedMemory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoomServiceServer).PutSharedMemory(ctx, req.(*PutSharedMemoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoomService_GetSharedMemory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSharedMemoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoomServiceServer).GetSharedMemory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoomService_GetSharedMemory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoomServiceServer).GetSharedMemory(ctx, req.(*GetSharedMemoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoomService_DeleteSharedMemory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteSharedMemoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoomServiceServer).DeleteSharedMemory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoomService_DeleteSharedMemory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoomServiceServer).DeleteSharedMemory(ctx, req.(*DeleteSharedMemoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoomService_WatchSharedMemory_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchSharedMemoryRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LoomServiceServer).WatchSharedMemory(m, &grpc.GenericServerStream[WatchSharedMemoryRequest, SharedMemoryValue]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type LoomService_WatchSharedMemoryServer = grpc.ServerStreamingServer[SharedMemoryValue]

func _LoomService_ListSharedMemoryKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListSharedMemoryKeysRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoomServiceServer).ListSharedMemoryKeys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoomService_ListSharedMemoryKeys_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoomServiceServer).ListSharedMemoryKeys(ctx, req.(*ListSharedMemoryKeysRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoomService_GetSharedMemoryStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSharedMemoryStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoomServiceServer).GetSharedMemoryStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoomService_GetSharedMemoryStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoomServiceServer).GetSharedMemoryStats(ctx, req.(*GetSharedMemoryStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoomService_ListArtifacts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListArtifactsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoomServiceServer).ListArtifacts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoomService_ListArtifacts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoomServiceServer).ListArtifacts(ctx, req.(*ListArtifactsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoomService_GetArtifact_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetArtifactRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoomServiceServer).GetArtifact(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoomService_GetArtifact_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoomServiceServer).GetArtifact(ctx, req.(*GetArtifactRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoomService_UploadArtifact_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UploadArtifactRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoomServiceServer).UploadArtifact(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoomService_UploadArtifact_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoomServiceServer).UploadArtifact(ctx, req.(*UploadArtifactRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoomService_DeleteArtifact_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteArtifactRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoomServiceServer).DeleteArtifact(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoomService_DeleteArtifact_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoomServiceServer).DeleteArtifact(ctx, req.(*DeleteArtifactRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoomService_SearchArtifacts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchArtifactsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoomServiceServer).SearchArtifacts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoomService_SearchArtifacts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoomServiceServer).SearchArtifacts(ctx, req.(*SearchArtifactsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoomService_GetArtifactContent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetArtifactContentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoomServiceServer).GetArtifactContent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoomService_GetArtifactContent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoomServiceServer).GetArtifactContent(ctx, req.(*GetArtifactContentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoomService_GetArtifactStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetArtifactStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoomServiceServer).GetArtifactStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LoomService_GetArtifactStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoomServiceServer).GetArtifactStats(ctx, req.(*GetArtifactStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// LoomService_ServiceDesc is the grpc.ServiceDesc for LoomService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LoomService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "loom.v1.LoomService",
	HandlerType: (*LoomServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Weave",
			Handler:    _LoomService_Weave_Handler,
		},
		{
			MethodName: "LoadPatterns",
			Handler:    _LoomService_LoadPatterns_Handler,
		},
		{
			MethodName: "ListPatterns",
			Handler:    _LoomService_ListPatterns_Handler,
		},
		{
			MethodName: "GetPattern",
			Handler:    _LoomService_GetPattern_Handler,
		},
		{
			MethodName: "CreatePattern",
			Handler:    _LoomService_CreatePattern_Handler,
		},
		{
			MethodName: "AnswerClarificationQuestion",
			Handler:    _LoomService_AnswerClarificationQuestion_Handler,
		},
		{
			MethodName: "CreateSession",
			Handler:    _LoomService_CreateSession_Handler,
		},
		{
			MethodName: "GetSession",
			Handler:    _LoomService_GetSession_Handler,
		},
		{
			MethodName: "ListSessions",
			Handler:    _LoomService_ListSessions_Handler,
		},
		{
			MethodName: "DeleteSession",
			Handler:    _LoomService_DeleteSession_Handler,
		},
		{
			MethodName: "GetConversationHistory",
			Handler:    _LoomService_GetConversationHistory_Handler,
		},
		{
			MethodName: "RegisterTool",
			Handler:    _LoomService_RegisterTool_Handler,
		},
		{
			MethodName: "ListTools",
			Handler:    _LoomService_ListTools_Handler,
		},
		{
			MethodName: "GetTrace",
			Handler:    _LoomService_GetTrace_Handler,
		},
		{
			MethodName: "GetHealth",
			Handler:    _LoomService_GetHealth_Handler,
		},
		{
			MethodName: "GetServerConfig",
			Handler:    _LoomService_GetServerConfig_Handler,
		},
		{
			MethodName: "GetTLSStatus",
			Handler:    _LoomService_GetTLSStatus_Handler,
		},
		{
			MethodName: "RenewCertificate",
			Handler:    _LoomService_RenewCertificate_Handler,
		},
		{
			MethodName: "CreateAgentFromConfig",
			Handler:    _LoomService_CreateAgentFromConfig_Handler,
		},
		{
			MethodName: "ListAgents",
			Handler:    _LoomService_ListAgents_Handler,
		},
		{
			MethodName: "GetAgent",
			Handler:    _LoomService_GetAgent_Handler,
		},
		{
			MethodName: "StartAgent",
			Handler:    _LoomService_StartAgent_Handler,
		},
		{
			MethodName: "StopAgent",
			Handler:    _LoomService_StopAgent_Handler,
		},
		{
			MethodName: "DeleteAgent",
			Handler:    _LoomService_DeleteAgent_Handler,
		},
		{
			MethodName: "ReloadAgent",
			Handler:    _LoomService_ReloadAgent_Handler,
		},
		{
			MethodName: "SwitchModel",
			Handler:    _LoomService_SwitchModel_Handler,
		},
		{
			MethodName: "ListAvailableModels",
			Handler:    _LoomService_ListAvailableModels_Handler,
		},
		{
			MethodName: "RequestToolPermission",
			Handler:    _LoomService_RequestToolPermission_Handler,
		},
		{
			MethodName: "ListMCPServers",
			Handler:    _LoomService_ListMCPServers_Handler,
		},
		{
			MethodName: "GetMCPServer",
			Handler:    _LoomService_GetMCPServer_Handler,
		},
		{
			MethodName: "AddMCPServer",
			Handler:    _LoomService_AddMCPServer_Handler,
		},
		{
			MethodName: "UpdateMCPServer",
			Handler:    _LoomService_UpdateMCPServer_Handler,
		},
		{
			MethodName: "DeleteMCPServer",
			Handler:    _LoomService_DeleteMCPServer_Handler,
		},
		{
			MethodName: "RestartMCPServer",
			Handler:    _LoomService_RestartMCPServer_Handler,
		},
		{
			MethodName: "HealthCheckMCPServers",
			Handler:    _LoomService_HealthCheckMCPServers_Handler,
		},
		{
			MethodName: "TestMCPServerConnection",
			Handler:    _LoomService_TestMCPServerConnection_Handler,
		},
		{
			MethodName: "ListMCPServerTools",
			Handler:    _LoomService_ListMCPServerTools_Handler,
		},
		{
			MethodName: "ExecuteWorkflow",
			Handler:    _LoomService_ExecuteWorkflow_Handler,
		},
		{
			MethodName: "GetWorkflowExecution",
			Handler:    _LoomService_GetWorkflowExecution_Handler,
		},
		{
			MethodName: "ListWorkflowExecutions",
			Handler:    _LoomService_ListWorkflowExecutions_Handler,
		},
		{
			MethodName: "ScheduleWorkflow",
			Handler:    _LoomService_ScheduleWorkflow_Handler,
		},
		{
			MethodName: "UpdateScheduledWorkflow",
			Handler:    _LoomService_UpdateScheduledWorkflow_Handler,
		},
		{
			MethodName: "GetScheduledWorkflow",
			Handler:    _LoomService_GetScheduledWorkflow_Handler,
		},
		{
			MethodName: "ListScheduledWorkflows",
			Handler:    _LoomService_ListScheduledWorkflows_Handler,
		},
		{
			MethodName: "DeleteScheduledWorkflow",
			Handler:    _LoomService_DeleteScheduledWorkflow_Handler,
		},
		{
			MethodName: "TriggerScheduledWorkflow",
			Handler:    _LoomService_TriggerScheduledWorkflow_Handler,
		},
		{
			MethodName: "PauseSchedule",
			Handler:    _LoomService_PauseSchedule_Handler,
		},
		{
			MethodName: "ResumeSchedule",
			Handler:    _LoomService_ResumeSchedule_Handler,
		},
		{
			MethodName: "GetScheduleHistory",
			Handler:    _LoomService_GetScheduleHistory_Handler,
		},
		{
			MethodName: "Publish",
			Handler:    _LoomService_Publish_Handler,
		},
		{
			MethodName: "Unsubscribe",
			Handler:    _LoomService_Unsubscribe_Handler,
		},
		{
			MethodName: "ListTopics",
			Handler:    _LoomService_ListTopics_Handler,
		},
		{
			MethodName: "GetTopicStats",
			Handler:    _LoomService_GetTopicStats_Handler,
		},
		{
			MethodName: "SendAsync",
			Handler:    _LoomService_SendAsync_Handler,
		},
		{
			MethodName: "SendAndReceive",
			Handler:    _LoomService_SendAndReceive_Handler,
		},
		{
			MethodName: "PutSharedMemory",
			Handler:    _LoomService_PutSharedMemory_Handler,
		},
		{
			MethodName: "GetSharedMemory",
			Handler:    _LoomService_GetSharedMemory_Handler,
		},
		{
			MethodName: "DeleteSharedMemory",
			Handler:    _LoomService_DeleteSharedMemory_Handler,
		},
		{
			MethodName: "ListSharedMemoryKeys",
			Handler:    _LoomService_ListSharedMemoryKeys_Handler,
		},
		{
			MethodName: "GetSharedMemoryStats",
			Handler:    _LoomService_GetSharedMemoryStats_Handler,
		},
		{
			MethodName: "ListArtifacts",
			Handler:    _LoomService_ListArtifacts_Handler,
		},
		{
			MethodName: "GetArtifact",
			Handler:    _LoomService_GetArtifact_Handler,
		},
		{
			MethodName: "UploadArtifact",
			Handler:    _LoomService_UploadArtifact_Handler,
		},
		{
			MethodName: "DeleteArtifact",
			Handler:    _LoomService_DeleteArtifact_Handler,
		},
		{
			MethodName: "SearchArtifacts",
			Handler:    _LoomService_SearchArtifacts_Handler,
		},
		{
			MethodName: "GetArtifactContent",
			Handler:    _LoomService_GetArtifactContent_Handler,
		},
		{
			MethodName: "GetArtifactStats",
			Handler:    _LoomService_GetArtifactStats_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamWeave",
			Handler:       _LoomService_StreamWeave_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamPatternUpdates",
			Handler:       _LoomService_StreamPatternUpdates_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeToSession",
			Handler:       _LoomService_SubscribeToSession_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamWorkflow",
			Handler:       _LoomService_StreamWorkflow_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Subscribe",
			Handler:       _LoomService_Subscribe_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "WatchSharedMemory",
			Handler:       _LoomService_WatchSharedMemory_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "loom/v1/loom.proto",
}

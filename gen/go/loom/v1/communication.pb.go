// Copyright 2026 Teradata
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        (unknown)
// source: loom/v1/communication.proto

package loomv1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// CommunicationTier defines the three-tier communication model.
type CommunicationTier int32

const (
	CommunicationTier_COMMUNICATION_TIER_UNSPECIFIED CommunicationTier = 0
	// Tier 1: Always reference (shared mutable state, workflow context)
	CommunicationTier_COMMUNICATION_TIER_ALWAYS_REFERENCE CommunicationTier = 1
	// Tier 2: Auto-promote based on size (>1KB default)
	CommunicationTier_COMMUNICATION_TIER_AUTO_PROMOTE CommunicationTier = 2
	// Tier 3: Always value (control messages, pattern refs, config)
	CommunicationTier_COMMUNICATION_TIER_ALWAYS_VALUE CommunicationTier = 3
)

// Enum value maps for CommunicationTier.
var (
	CommunicationTier_name = map[int32]string{
		0: "COMMUNICATION_TIER_UNSPECIFIED",
		1: "COMMUNICATION_TIER_ALWAYS_REFERENCE",
		2: "COMMUNICATION_TIER_AUTO_PROMOTE",
		3: "COMMUNICATION_TIER_ALWAYS_VALUE",
	}
	CommunicationTier_value = map[string]int32{
		"COMMUNICATION_TIER_UNSPECIFIED":      0,
		"COMMUNICATION_TIER_ALWAYS_REFERENCE": 1,
		"COMMUNICATION_TIER_AUTO_PROMOTE":     2,
		"COMMUNICATION_TIER_ALWAYS_VALUE":     3,
	}
)

func (x CommunicationTier) Enum() *CommunicationTier {
	p := new(CommunicationTier)
	*p = x
	return p
}

func (x CommunicationTier) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (CommunicationTier) Descriptor() protoreflect.EnumDescriptor {
	return file_loom_v1_communication_proto_enumTypes[0].Descriptor()
}

func (CommunicationTier) Type() protoreflect.EnumType {
	return &file_loom_v1_communication_proto_enumTypes[0]
}

func (x CommunicationTier) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use CommunicationTier.Descriptor instead.
func (CommunicationTier) EnumDescriptor() ([]byte, []int) {
	return file_loom_v1_communication_proto_rawDescGZIP(), []int{0}
}

// ReferenceType categorizes the kind of data stored in a reference.
type ReferenceType int32

const (
	ReferenceType_REFERENCE_TYPE_UNSPECIFIED         ReferenceType = 0
	ReferenceType_REFERENCE_TYPE_SESSION_STATE       ReferenceType = 1
	ReferenceType_REFERENCE_TYPE_WORKFLOW_CONTEXT    ReferenceType = 2
	ReferenceType_REFERENCE_TYPE_COLLABORATION_STATE ReferenceType = 3
	ReferenceType_REFERENCE_TYPE_LARGE_PAYLOAD       ReferenceType = 4
	ReferenceType_REFERENCE_TYPE_PATTERN_DATA        ReferenceType = 5
	ReferenceType_REFERENCE_TYPE_TOOL_RESULT         ReferenceType = 6
	ReferenceType_REFERENCE_TYPE_OBSERVABILITY_TRACE ReferenceType = 7
)

// Enum value maps for ReferenceType.
var (
	ReferenceType_name = map[int32]string{
		0: "REFERENCE_TYPE_UNSPECIFIED",
		1: "REFERENCE_TYPE_SESSION_STATE",
		2: "REFERENCE_TYPE_WORKFLOW_CONTEXT",
		3: "REFERENCE_TYPE_COLLABORATION_STATE",
		4: "REFERENCE_TYPE_LARGE_PAYLOAD",
		5: "REFERENCE_TYPE_PATTERN_DATA",
		6: "REFERENCE_TYPE_TOOL_RESULT",
		7: "REFERENCE_TYPE_OBSERVABILITY_TRACE",
	}
	ReferenceType_value = map[string]int32{
		"REFERENCE_TYPE_UNSPECIFIED":         0,
		"REFERENCE_TYPE_SESSION_STATE":       1,
		"REFERENCE_TYPE_WORKFLOW_CONTEXT":    2,
		"REFERENCE_TYPE_COLLABORATION_STATE": 3,
		"REFERENCE_TYPE_LARGE_PAYLOAD":       4,
		"REFERENCE_TYPE_PATTERN_DATA":        5,
		"REFERENCE_TYPE_TOOL_RESULT":         6,
		"REFERENCE_TYPE_OBSERVABILITY_TRACE": 7,
	}
)

func (x ReferenceType) Enum() *ReferenceType {
	p := new(ReferenceType)
	*p = x
	return p
}

func (x ReferenceType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ReferenceType) Descriptor() protoreflect.EnumDescriptor {
	return file_loom_v1_communication_proto_enumTypes[1].Descriptor()
}

func (ReferenceType) Type() protoreflect.EnumType {
	return &file_loom_v1_communication_proto_enumTypes[1]
}

func (x ReferenceType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ReferenceType.Descriptor instead.
func (ReferenceType) EnumDescriptor() ([]byte, []int) {
	return file_loom_v1_communication_proto_rawDescGZIP(), []int{1}
}

// ReferenceStore identifies the backend storage for references.
type ReferenceStore int32

const (
	ReferenceStore_REFERENCE_STORE_UNSPECIFIED ReferenceStore = 0
	ReferenceStore_REFERENCE_STORE_MEMORY      ReferenceStore = 1
	ReferenceStore_REFERENCE_STORE_SQLITE      ReferenceStore = 2
	ReferenceStore_REFERENCE_STORE_REDIS       ReferenceStore = 3
)

// Enum value maps for ReferenceStore.
var (
	ReferenceStore_name = map[int32]string{
		0: "REFERENCE_STORE_UNSPECIFIED",
		1: "REFERENCE_STORE_MEMORY",
		2: "REFERENCE_STORE_SQLITE",
		3: "REFERENCE_STORE_REDIS",
	}
	ReferenceStore_value = map[string]int32{
		"REFERENCE_STORE_UNSPECIFIED": 0,
		"REFERENCE_STORE_MEMORY":      1,
		"REFERENCE_STORE_SQLITE":      2,
		"REFERENCE_STORE_REDIS":       3,
	}
)

func (x ReferenceStore) Enum() *ReferenceStore {
	p := new(ReferenceStore)
	*p = x
	return p
}

func (x ReferenceStore) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ReferenceStore) Descriptor() protoreflect.EnumDescriptor {
	return file_loom_v1_communication_proto_enumTypes[2].Descriptor()
}

func (ReferenceStore) Type() protoreflect.EnumType {
	return &file_loom_v1_communication_proto_enumTypes[2]
}

func (x ReferenceStore) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ReferenceStore.Descriptor instead.
func (ReferenceStore) EnumDescriptor() ([]byte, []int) {
	return file_loom_v1_communication_proto_rawDescGZIP(), []int{2}
}

// Force reference or force value
type PolicyOverride_OverrideType int32

const (
	PolicyOverride_OVERRIDE_TYPE_UNSPECIFIED     PolicyOverride_OverrideType = 0
	PolicyOverride_OVERRIDE_TYPE_FORCE_REFERENCE PolicyOverride_OverrideType = 1
	PolicyOverride_OVERRIDE_TYPE_FORCE_VALUE     PolicyOverride_OverrideType = 2
)

// Enum value maps for PolicyOverride_OverrideType.
var (
	PolicyOverride_OverrideType_name = map[int32]string{
		0: "OVERRIDE_TYPE_UNSPECIFIED",
		1: "OVERRIDE_TYPE_FORCE_REFERENCE",
		2: "OVERRIDE_TYPE_FORCE_VALUE",
	}
	PolicyOverride_OverrideType_value = map[string]int32{
		"OVERRIDE_TYPE_UNSPECIFIED":     0,
		"OVERRIDE_TYPE_FORCE_REFERENCE": 1,
		"OVERRIDE_TYPE_FORCE_VALUE":     2,
	}
)

func (x PolicyOverride_OverrideType) Enum() *PolicyOverride_OverrideType {
	p := new(PolicyOverride_OverrideType)
	*p = x
	return p
}

func (x PolicyOverride_OverrideType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (PolicyOverride_OverrideType) Descriptor() protoreflect.EnumDescriptor {
	return file_loom_v1_communication_proto_enumTypes[3].Descriptor()
}

func (PolicyOverride_OverrideType) Type() protoreflect.EnumType {
	return &file_loom_v1_communication_proto_enumTypes[3]
}

func (x PolicyOverride_OverrideType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use PolicyOverride_OverrideType.Descriptor instead.
func (PolicyOverride_OverrideType) EnumDescriptor() ([]byte, []int) {
	return file_loom_v1_communication_proto_rawDescGZIP(), []int{6, 0}
}

// CommunicationMessage is the envelope for all agent-to-agent communication.
// This is distinct from conversation Message (user/assistant/tool messages).
type CommunicationMessage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Unique message identifier
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Source agent ID
	FromAgent string `protobuf:"bytes,2,opt,name=from_agent,json=fromAgent,proto3" json:"from_agent,omitempty"`
	// Destination agent ID
	ToAgent string `protobuf:"bytes,3,opt,name=to_agent,json=toAgent,proto3" json:"to_agent,omitempty"`
	// Message payload (value or reference)
	Payload *MessagePayload `protobuf:"bytes,4,opt,name=payload,proto3" json:"payload,omitempty"`
	// Communication policy applied to this message
	Policy *CommunicationPolicy `protobuf:"bytes,5,opt,name=policy,proto3" json:"policy,omitempty"`
	// Message timestamp (Unix seconds)
	Timestamp     int64 `protobuf:"varint,6,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CommunicationMessage) Reset() {
	*x = CommunicationMessage{}
	mi := &file_loom_v1_communication_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CommunicationMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CommunicationMessage) ProtoMessage() {}

func (x *CommunicationMessage) ProtoReflect() protoreflect.Message {
	mi := &file_loom_v1_communication_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CommunicationMessage.ProtoReflect.Descriptor instead.
func (*CommunicationMessage) Descriptor() ([]byte, []int) {
	return file_loom_v1_communication_proto_rawDescGZIP(), []int{0}
}

func (x *CommunicationMessage) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *CommunicationMessage) GetFromAgent() string {
	if x != nil {
		return x.FromAgent
	}
	return ""
}

func (x *CommunicationMessage) GetToAgent() string {
	if x != nil {
		return x.ToAgent
	}
	return ""
}

func (x *CommunicationMessage) GetPayload() *MessagePayload {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *CommunicationMessage) GetPolicy() *CommunicationPolicy {
	if x != nil {
		return x.Policy
	}
	return nil
}

func (x *CommunicationMessage) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

// MessagePayload contains either direct value or reference to data.
type MessagePayload struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Data can be either value (direct) or reference (indirect)
	//
	// Types that are valid to be assigned to Data:
	//
	//	*MessagePayload_Value
	//	*MessagePayload_Reference
	Data isMessagePayload_Data `protobuf_oneof:"data"`
	// Payload metadata (size, content type, etc.)
	Metadata      *PayloadMetadata `protobuf:"bytes,3,opt,name=metadata,proto3" json:"metadata,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MessagePayload) Reset() {
	*x = MessagePayload{}
	mi := &file_loom_v1_communication_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MessagePayload) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MessagePayload) ProtoMessage() {}

func (x *MessagePayload) ProtoReflect() protoreflect.Message {
	mi := &file_loom_v1_communication_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MessagePayload.ProtoReflect.Descriptor instead.
func (*MessagePayload) Descriptor() ([]byte, []int) {
	return file_loom_v1_communication_proto_rawDescGZIP(), []int{1}
}

func (x *MessagePayload) GetData() isMessagePayload_Data {
	if x != nil {
		return x.Data
	}
	return nil
}

func (x *MessagePayload) GetValue() []byte {
	if x != nil {
		if x, ok := x.Data.(*MessagePayload_Value); ok {
			return x.Value
		}
	}
	return nil
}

func (x *MessagePayload) GetReference() *Reference {
	if x != nil {
		if x, ok := x.Data.(*MessagePayload_Reference); ok {
			return x.Reference
		}
	}
	return nil
}

func (x *MessagePayload) GetMetadata() *PayloadMetadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

type isMessagePayload_Data interface {
	isMessagePayload_Data()
}

type MessagePayload_Value struct {
	// Direct value (small payloads, control messages)
	Value []byte `protobuf:"bytes,1,opt,name=value,proto3,oneof"`
}

type MessagePayload_Reference struct {
	// Reference to shared data (large payloads, shared state)
	Reference *Reference `protobuf:"bytes,2,opt,name=reference,proto3,oneof"`
}

func (*MessagePayload_Value) isMessagePayload_Data() {}

func (*MessagePayload_Reference) isMessagePayload_Data() {}

// Reference points to data stored in a ReferenceStore.
type Reference struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Unique reference identifier
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Type of data being referenced
	Type ReferenceType `protobuf:"varint,2,opt,name=type,proto3,enum=loom.v1.ReferenceType" json:"type,omitempty"`
	// Storage backend where data is stored
	Store ReferenceStore `protobuf:"varint,3,opt,name=store,proto3,enum=loom.v1.ReferenceStore" json:"store,omitempty"`
	// Reference creation timestamp (Unix seconds)
	CreatedAt int64 `protobuf:"varint,4,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	// Reference expiry timestamp (Unix seconds, 0 = never expires)
	ExpiresAt     int64 `protobuf:"varint,5,opt,name=expires_at,json=expiresAt,proto3" json:"expires_at,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Reference) Reset() {
	*x = Reference{}
	mi := &file_loom_v1_communication_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Reference) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Reference) ProtoMessage() {}

func (x *Reference) ProtoReflect() protoreflect.Message {
	mi := &file_loom_v1_communication_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Reference.ProtoReflect.Descriptor instead.
func (*Reference) Descriptor() ([]byte, []int) {
	return file_loom_v1_communication_proto_rawDescGZIP(), []int{2}
}

func (x *Reference) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *Reference) GetType() ReferenceType {
	if x != nil {
		return x.Type
	}
	return ReferenceType_REFERENCE_TYPE_UNSPECIFIED
}

func (x *Reference) GetStore() ReferenceStore {
	if x != nil {
		return x.Store
	}
	return ReferenceStore_REFERENCE_STORE_UNSPECIFIED
}

func (x *Reference) GetCreatedAt() int64 {
	if x != nil {
		return x.CreatedAt
	}
	return 0
}

func (x *Reference) GetExpiresAt() int64 {
	if x != nil {
		return x.ExpiresAt
	}
	return 0
}

// PayloadMetadata provides information about the payload.
type PayloadMetadata struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Size of actual data in bytes
	SizeBytes int64 `protobuf:"varint,1,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`
	// MIME content type (e.g., "application/json", "text/plain")
	ContentType string `protobuf:"bytes,2,opt,name=content_type,json=contentType,proto3" json:"content_type,omitempty"`
	// Optional checksum for data integrity
	Checksum string `protobuf:"bytes,3,opt,name=checksum,proto3" json:"checksum,omitempty"`
	// Compression applied (if any): "none", "gzip", "zstd"
	Compression string `protobuf:"bytes,4,opt,name=compression,proto3" json:"compression,omitempty"`
	// Encoding applied (if any): "none", "base64"
	Encoding      string `protobuf:"bytes,5,opt,name=encoding,proto3" json:"encoding,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PayloadMetadata) Reset() {
	*x = PayloadMetadata{}
	mi := &file_loom_v1_communication_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PayloadMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PayloadMetadata) ProtoMessage() {}

func (x *PayloadMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_loom_v1_communication_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PayloadMetadata.ProtoReflect.Descriptor instead.
func (*PayloadMetadata) Descriptor() ([]byte, []int) {
	return file_loom_v1_communication_proto_rawDescGZIP(), []int{3}
}

func (x *PayloadMetadata) GetSizeBytes() int64 {
	if x != nil {
		return x.SizeBytes
	}
	return 0
}

func (x *PayloadMetadata) GetContentType() string {
	if x != nil {
		return x.ContentType
	}
	return ""
}

func (x *PayloadMetadata) GetChecksum() string {
	if x != nil {
		return x.Checksum
	}
	return ""
}

func (x *PayloadMetadata) GetCompression() string {
	if x != nil {
		return x.Compression
	}
	return ""
}

func (x *PayloadMetadata) GetEncoding() string {
	if x != nil {
		return x.Encoding
	}
	return ""
}

// CommunicationPolicy defines when to use references vs values.
type CommunicationPolicy struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Communication tier for this message type
	Tier CommunicationTier `protobuf:"varint,1,opt,name=tier,proto3,enum=loom.v1.CommunicationTier" json:"tier,omitempty"`
	// Message type (e.g., "session_state", "control", "data")
	MessageType string `protobuf:"bytes,2,opt,name=message_type,json=messageType,proto3" json:"message_type,omitempty"`
	// Auto-promotion settings
	AutoPromote *AutoPromoteConfig `protobuf:"bytes,3,opt,name=auto_promote,json=autoPromote,proto3" json:"auto_promote,omitempty"`
	// Policy overrides (force reference or value)
	Overrides     map[string]*PolicyOverride `protobuf:"bytes,4,rep,name=overrides,proto3" json:"overrides,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CommunicationPolicy) Reset() {
	*x = CommunicationPolicy{}
	mi := &file_loom_v1_communication_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CommunicationPolicy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CommunicationPolicy) ProtoMessage() {}

func (x *CommunicationPolicy) ProtoReflect() protoreflect.Message {
	mi := &file_loom_v1_communication_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CommunicationPolicy.ProtoReflect.Descriptor instead.
func (*CommunicationPolicy) Descriptor() ([]byte, []int) {
	return file_loom_v1_communication_proto_rawDescGZIP(), []int{4}
}

func (x *CommunicationPolicy) GetTier() CommunicationTier {
	if x != nil {
		return x.Tier
	}
	return CommunicationTier_COMMUNICATION_TIER_UNSPECIFIED
}

func (x *CommunicationPolicy) GetMessageType() string {
	if x != nil {
		return x.MessageType
	}
	return ""
}

func (x *CommunicationPolicy) GetAutoPromote() *AutoPromoteConfig {
	if x != nil {
		return x.AutoPromote
	}
	return nil
}

func (x *CommunicationPolicy) GetOverrides() map[string]*PolicyOverride {
	if x != nil {
		return x.Overrides
	}
	return nil
}

// AutoPromoteConfig controls automatic value-to-reference promotion.
type AutoPromoteConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Enable automatic promotion based on size
	Enabled bool `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// Size threshold in bytes (default: 1024 = 1KB)
	ThresholdBytes int64 `protobuf:"varint,2,opt,name=threshold_bytes,json=thresholdBytes,proto3" json:"threshold_bytes,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *AutoPromoteConfig) Reset() {
	*x = AutoPromoteConfig{}
	mi := &file_loom_v1_communication_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AutoPromoteConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AutoPromoteConfig) ProtoMessage() {}

func (x *AutoPromoteConfig) ProtoReflect() protoreflect.Message {
	mi := &file_loom_v1_communication_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AutoPromoteConfig.ProtoReflect.Descriptor instead.
func (*AutoPromoteConfig) Descriptor() ([]byte, []int) {
	return file_loom_v1_communication_proto_rawDescGZIP(), []int{5}
}

func (x *AutoPromoteConfig) GetEnabled() bool {
	if x != nil {
		return x.Enabled
	}
	return false
}

func (x *AutoPromoteConfig) GetThresholdBytes() int64 {
	if x != nil {
		return x.ThresholdBytes
	}
	return 0
}

// PolicyOverride forces specific behavior for a message type.
type PolicyOverride struct {
	state protoimpl.MessageState      `protogen:"open.v1"`
	Type  PolicyOverride_OverrideType `protobuf:"varint,1,opt,name=type,proto3,enum=loom.v1.PolicyOverride_OverrideType" json:"type,omitempty"`
	// Reason for override (documentation)
	Reason        string `protobuf:"bytes,2,opt,name=reason,proto3" json:"reason,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PolicyOverride) Reset() {
	*x = PolicyOverride{}
	mi := &file_loom_v1_communication_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PolicyOverride) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PolicyOverride) ProtoMessage() {}

func (x *PolicyOverride) ProtoReflect() protoreflect.Message {
	mi := &file_loom_v1_communication_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PolicyOverride.ProtoReflect.Descriptor instead.
func (*PolicyOverride) Descriptor() ([]byte, []int) {
	return file_loom_v1_communication_proto_rawDescGZIP(), []int{6}
}

func (x *PolicyOverride) GetType() PolicyOverride_OverrideType {
	if x != nil {
		return x.Type
	}
	return PolicyOverride_OVERRIDE_TYPE_UNSPECIFIED
}

func (x *PolicyOverride) GetReason() string {
	if x != nil {
		return x.Reason
	}
	return ""
}

// ReferenceStoreStats provides statistics about reference storage.
type ReferenceStoreStats struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Total references ever created
	TotalRefs int64 `protobuf:"varint,1,opt,name=total_refs,json=totalRefs,proto3" json:"total_refs,omitempty"`
	// Total bytes ever stored
	TotalBytes int64 `protobuf:"varint,2,opt,name=total_bytes,json=totalBytes,proto3" json:"total_bytes,omitempty"`
	// Currently active references
	ActiveRefs int64 `protobuf:"varint,3,opt,name=active_refs,json=activeRefs,proto3" json:"active_refs,omitempty"`
	// Garbage collection runs
	GcRuns int64 `protobuf:"varint,4,opt,name=gc_runs,json=gcRuns,proto3" json:"gc_runs,omitempty"`
	// References evicted by GC
	EvictionCount int64 `protobuf:"varint,5,opt,name=eviction_count,json=evictionCount,proto3" json:"eviction_count,omitempty"`
	// Current memory usage (bytes)
	CurrentBytes  int64 `protobuf:"varint,6,opt,name=current_bytes,json=currentBytes,proto3" json:"current_bytes,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ReferenceStoreStats) Reset() {
	*x = ReferenceStoreStats{}
	mi := &file_loom_v1_communication_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReferenceStoreStats) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReferenceStoreStats) ProtoMessage() {}

func (x *ReferenceStoreStats) ProtoReflect() protoreflect.Message {
	mi := &file_loom_v1_communication_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReferenceStoreStats.ProtoReflect.Descriptor instead.
func (*ReferenceStoreStats) Descriptor() ([]byte, []int) {
	return file_loom_v1_communication_proto_rawDescGZIP(), []int{7}
}

func (x *ReferenceStoreStats) GetTotalRefs() int64 {
	if x != nil {
		return x.TotalRefs
	}
	return 0
}

func (x *ReferenceStoreStats) GetTotalBytes() int64 {
	if x != nil {
		return x.TotalBytes
	}
	return 0
}

func (x *ReferenceStoreStats) GetActiveRefs() int64 {
	if x != nil {
		return x.ActiveRefs
	}
	return 0
}

func (x *ReferenceStoreStats) GetGcRuns() int64 {
	if x != nil {
		return x.GcRuns
	}
	return 0
}

func (x *ReferenceStoreStats) GetEvictionCount() int64 {
	if x != nil {
		return x.EvictionCount
	}
	return 0
}

func (x *ReferenceStoreStats) GetCurrentBytes() int64 {
	if x != nil {
		return x.CurrentBytes
	}
	return 0
}

// SendAsyncRequest sends a message asynchronously (fire-and-forget).
type SendAsyncRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Destination agent ID
	ToAgent string `protobuf:"bytes,1,opt,name=to_agent,json=toAgent,proto3" json:"to_agent,omitempty"`
	// Source agent ID
	FromAgent string `protobuf:"bytes,2,opt,name=from_agent,json=fromAgent,proto3" json:"from_agent,omitempty"`
	// Message type for routing/filtering
	MessageType string `protobuf:"bytes,3,opt,name=message_type,json=messageType,proto3" json:"message_type,omitempty"`
	// Message payload (value or reference, auto-promoted based on size)
	Payload *MessagePayload `protobuf:"bytes,4,opt,name=payload,proto3" json:"payload,omitempty"`
	// Optional metadata
	Metadata map[string]string `protobuf:"bytes,5,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Communication policy to apply
	Policy        *CommunicationPolicy `protobuf:"bytes,6,opt,name=policy,proto3" json:"policy,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SendAsyncRequest) Reset() {
	*x = SendAsyncRequest{}
	mi := &file_loom_v1_communication_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SendAsyncRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SendAsyncRequest) ProtoMessage() {}

func (x *SendAsyncRequest) ProtoReflect() protoreflect.Message {
	mi := &file_loom_v1_communication_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SendAsyncRequest.ProtoReflect.Descriptor instead.
func (*SendAsyncRequest) Descriptor() ([]byte, []int) {
	return file_loom_v1_communication_proto_rawDescGZIP(), []int{8}
}

func (x *SendAsyncRequest) GetToAgent() string {
	if x != nil {
		return x.ToAgent
	}
	return ""
}

func (x *SendAsyncRequest) GetFromAgent() string {
	if x != nil {
		return x.FromAgent
	}
	return ""
}

func (x *SendAsyncRequest) GetMessageType() string {
	if x != nil {
		return x.MessageType
	}
	return ""
}

func (x *SendAsyncRequest) GetPayload() *MessagePayload {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *SendAsyncRequest) GetMetadata() map[string]string {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *SendAsyncRequest) GetPolicy() *CommunicationPolicy {
	if x != nil {
		return x.Policy
	}
	return nil
}

// SendAsyncResponse confirms the async send operation.
type SendAsyncResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Unique message ID for tracking
	MessageId string `protobuf:"bytes,1,opt,name=message_id,json=messageId,proto3" json:"message_id,omitempty"`
	// True if message was queued (destination agent offline)
	Queued bool `protobuf:"varint,2,opt,name=queued,proto3" json:"queued,omitempty"`
	// Timestamp when message was sent or queued (Unix milliseconds)
	Timestamp     int64 `protobuf:"varint,3,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SendAsyncResponse) Reset() {
	*x = SendAsyncResponse{}
	mi := &file_loom_v1_communication_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SendAsyncResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SendAsyncResponse) ProtoMessage() {}

func (x *SendAsyncResponse) ProtoReflect() protoreflect.Message {
	mi := &file_loom_v1_communication_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SendAsyncResponse.ProtoReflect.Descriptor instead.
func (*SendAsyncResponse) Descriptor() ([]byte, []int) {
	return file_loom_v1_communication_proto_rawDescGZIP(), []int{9}
}

func (x *SendAsyncResponse) GetMessageId() string {
	if x != nil {
		return x.MessageId
	}
	return ""
}

func (x *SendAsyncResponse) GetQueued() bool {
	if x != nil {
		return x.Queued
	}
	return false
}

func (x *SendAsyncResponse) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

// SendAndReceiveRequest sends a message and waits for response (RPC-style).
type SendAndReceiveRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Destination agent ID
	ToAgent string `protobuf:"bytes,1,opt,name=to_agent,json=toAgent,proto3" json:"to_agent,omitempty"`
	// Source agent ID
	FromAgent string `protobuf:"bytes,2,opt,name=from_agent,json=fromAgent,proto3" json:"from_agent,omitempty"`
	// Message type for routing/filtering
	MessageType string `protobuf:"bytes,3,opt,name=message_type,json=messageType,proto3" json:"message_type,omitempty"`
	// Message payload (value or reference, auto-promoted based on size)
	Payload *MessagePayload `protobuf:"bytes,4,opt,name=payload,proto3" json:"payload,omitempty"`
	// Optional metadata
	Metadata map[string]string `protobuf:"bytes,5,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Communication policy to apply
	Policy *CommunicationPolicy `protobuf:"bytes,6,opt,name=policy,proto3" json:"policy,omitempty"`
	// Timeout in seconds (0 = no timeout)
	TimeoutSeconds int32 `protobuf:"varint,7,opt,name=timeout_seconds,json=timeoutSeconds,proto3" json:"timeout_seconds,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *SendAndReceiveRequest) Reset() {
	*x = SendAndReceiveRequest{}
	mi := &file_loom_v1_communication_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SendAndReceiveRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SendAndReceiveRequest) ProtoMessage() {}

func (x *SendAndReceiveRequest) ProtoReflect() protoreflect.Message {
	mi := &file_loom_v1_communication_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SendAndReceiveRequest.ProtoReflect.Descriptor instead.
func (*SendAndReceiveRequest) Descriptor() ([]byte, []int) {
	return file_loom_v1_communication_proto_rawDescGZIP(), []int{10}
}

func (x *SendAndReceiveRequest) GetToAgent() string {
	if x != nil {
		return x.ToAgent
	}
	return ""
}

func (x *SendAndReceiveRequest) GetFromAgent() string {
	if x != nil {
		return x.FromAgent
	}
	return ""
}

func (x *SendAndReceiveRequest) GetMessageType() string {
	if x != nil {
		return x.MessageType
	}
	return ""
}

func (x *SendAndReceiveRequest) GetPayload() *MessagePayload {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *SendAndReceiveRequest) GetMetadata() map[string]string {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *SendAndReceiveRequest) GetPolicy() *CommunicationPolicy {
	if x != nil {
		return x.Policy
	}
	return nil
}

func (x *SendAndReceiveRequest) GetTimeoutSeconds() int32 {
	if x != nil {
		return x.TimeoutSeconds
	}
	return 0
}

// SendAndReceiveResponse contains the response from the destination agent.
type SendAndReceiveResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Original request message ID
	RequestId string `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// Response message ID
	ResponseId string `protobuf:"bytes,2,opt,name=response_id,json=responseId,proto3" json:"response_id,omitempty"`
	// Response payload from destination agent
	Payload *MessagePayload `protobuf:"bytes,3,opt,name=payload,proto3" json:"payload,omitempty"`
	// Response metadata
	Metadata map[string]string `protobuf:"bytes,4,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Timestamp when response was received (Unix milliseconds)
	Timestamp int64 `protobuf:"varint,5,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// True if request timed out (no response within timeout_seconds)
	TimedOut      bool `protobuf:"varint,6,opt,name=timed_out,json=timedOut,proto3" json:"timed_out,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SendAndReceiveResponse) Reset() {
	*x = SendAndReceiveResponse{}
	mi := &file_loom_v1_communication_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SendAndReceiveResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SendAndReceiveResponse) ProtoMessage() {}

func (x *SendAndReceiveResponse) ProtoReflect() protoreflect.Message {
	mi := &file_loom_v1_communication_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SendAndReceiveResponse.ProtoReflect.Descriptor instead.
func (*SendAndReceiveResponse) Descriptor() ([]byte, []int) {
	return file_loom_v1_communication_proto_rawDescGZIP(), []int{11}
}

func (x *SendAndReceiveResponse) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

func (x *SendAndReceiveResponse) GetResponseId() string {
	if x != nil {
		return x.ResponseId
	}
	return ""
}

func (x *SendAndReceiveResponse) GetPayload() *MessagePayload {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *SendAndReceiveResponse) GetMetadata() map[string]string {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *SendAndReceiveResponse) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *SendAndReceiveResponse) GetTimedOut() bool {
	if x != nil {
		return x.TimedOut
	}
	return false
}

var File_loom_v1_communication_proto protoreflect.FileDescriptor

const file_loom_v1_communication_proto_rawDesc = "" +
	"\n" +
	"\x1bloom/v1/communication.proto\x12\aloom.v1\"\xe7\x01\n" +
	"\x14CommunicationMessage\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x1d\n" +
	"\n" +
	"from_agent\x18\x02 \x01(\tR\tfromAgent\x12\x19\n" +
	"\bto_agent\x18\x03 \x01(\tR\atoAgent\x121\n" +
	"\apayload\x18\x04 \x01(\v2\x17.loom.v1.MessagePayloadR\apayload\x124\n" +
	"\x06policy\x18\x05 \x01(\v2\x1c.loom.v1.CommunicationPolicyR\x06policy\x12\x1c\n" +
	"\ttimestamp\x18\x06 \x01(\x03R\ttimestamp\"\x9a\x01\n" +
	"\x0eMessagePayload\x12\x16\n" +
	"\x05value\x18\x01 \x01(\fH\x00R\x05value\x122\n" +
	"\treference\x18\x02 \x01(\v2\x12.loom.v1.ReferenceH\x00R\treference\x124\n" +
	"\bmetadata\x18\x03 \x01(\v2\x18.loom.v1.PayloadMetadataR\bmetadataB\x06\n" +
	"\x04data\"\xb4\x01\n" +
	"\tReference\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12*\n" +
	"\x04type\x18\x02 \x01(\x0e2\x16.loom.v1.ReferenceTypeR\x04type\x12-\n" +
	"\x05store\x18\x03 \x01(\x0e2\x17.loom.v1.ReferenceStoreR\x05store\x12\x1d\n" +
	"\n" +
	"created_at\x18\x04 \x01(\x03R\tcreatedAt\x12\x1d\n" +
	"\n" +
	"expires_at\x18\x05 \x01(\x03R\texpiresAt\"\xad\x01\n" +
	"\x0fPayloadMetadata\x12\x1d\n" +
	"\n" +
	"size_bytes\x18\x01 \x01(\x03R\tsizeBytes\x12!\n" +
	"\fcontent_type\x18\x02 \x01(\tR\vcontentType\x12\x1a\n" +
	"\bchecksum\x18\x03 \x01(\tR\bchecksum\x12 \n" +
	"\vcompression\x18\x04 \x01(\tR\vcompression\x12\x1a\n" +
	"\bencoding\x18\x05 \x01(\tR\bencoding\"\xc9\x02\n" +
	"\x13CommunicationPolicy\x12.\n" +
	"\x04tier\x18\x01 \x01(\x0e2\x1a.loom.v1.CommunicationTierR\x04tier\x12!\n" +
	"\fmessage_type\x18\x02 \x01(\tR\vmessageType\x12=\n" +
	"\fauto_promote\x18\x03 \x01(\v2\x1a.loom.v1.AutoPromoteConfigR\vautoPromote\x12I\n" +
	"\toverrides\x18\x04 \x03(\v2+.loom.v1.CommunicationPolicy.OverridesEntryR\toverrides\x1aU\n" +
	"\x0eOverridesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12-\n" +
	"\x05value\x18\x02 \x01(\v2\x17.loom.v1.PolicyOverrideR\x05value:\x028\x01\"V\n" +
	"\x11AutoPromoteConfig\x12\x18\n" +
	"\aenabled\x18\x01 \x01(\bR\aenabled\x12'\n" +
	"\x0fthreshold_bytes\x18\x02 \x01(\x03R\x0ethresholdBytes\"\xd3\x01\n" +
	"\x0ePolicyOverride\x128\n" +
	"\x04type\x18\x01 \x01(\x0e2$.loom.v1.PolicyOverride.OverrideTypeR\x04type\x12\x16\n" +
	"\x06reason\x18\x02 \x01(\tR\x06reason\"o\n" +
	"\fOverrideType\x12\x1d\n" +
	"\x19OVERRIDE_TYPE_UNSPECIFIED\x10\x00\x12!\n" +
	"\x1dOVERRIDE_TYPE_FORCE_REFERENCE\x10\x01\x12\x1d\n" +
	"\x19OVERRIDE_TYPE_FORCE_VALUE\x10\x02\"\xdb\x01\n" +
	"\x13ReferenceStoreStats\x12\x1d\n" +
	"\n" +
	"total_refs\x18\x01 \x01(\x03R\ttotalRefs\x12\x1f\n" +
	"\vtotal_bytes\x18\x02 \x01(\x03R\n" +
	"totalBytes\x12\x1f\n" +
	"\vactive_refs\x18\x03 \x01(\x03R\n" +
	"activeRefs\x12\x17\n" +
	"\agc_runs\x18\x04 \x01(\x03R\x06gcRuns\x12%\n" +
	"\x0eeviction_count\x18\x05 \x01(\x03R\revictionCount\x12#\n" +
	"\rcurrent_bytes\x18\x06 \x01(\x03R\fcurrentBytes\"\xda\x02\n" +
	"\x10SendAsyncRequest\x12\x19\n" +
	"\bto_agent\x18\x01 \x01(\tR\atoAgent\x12\x1d\n" +
	"\n" +
	"from_agent\x18\x02 \x01(\tR\tfromAgent\x12!\n" +
	"\fmessage_type\x18\x03 \x01(\tR\vmessageType\x121\n" +
	"\apayload\x18\x04 \x01(\v2\x17.loom.v1.MessagePayloadR\apayload\x12C\n" +
	"\bmetadata\x18\x05 \x03(\v2'.loom.v1.SendAsyncRequest.MetadataEntryR\bmetadata\x124\n" +
	"\x06policy\x18\x06 \x01(\v2\x1c.loom.v1.CommunicationPolicyR\x06policy\x1a;\n" +
	"\rMetadataEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"h\n" +
	"\x11SendAsyncResponse\x12\x1d\n" +
	"\n" +
	"message_id\x18\x01 \x01(\tR\tmessageId\x12\x16\n" +
	"\x06queued\x18\x02 \x01(\bR\x06queued\x12\x1c\n" +
	"\ttimestamp\x18\x03 \x01(\x03R\ttimestamp\"\x8d\x03\n" +
	"\x15SendAndReceiveRequest\x12\x19\n" +
	"\bto_agent\x18\x01 \x01(\tR\atoAgent\x12\x1d\n" +
	"\n" +
	"from_agent\x18\x02 \x01(\tR\tfromAgent\x12!\n" +
	"\fmessage_type\x18\x03 \x01(\tR\vmessageType\x121\n" +
	"\apayload\x18\x04 \x01(\v2\x17.loom.v1.MessagePayloadR\apayload\x12H\n" +
	"\bmetadata\x18\x05 \x03(\v2,.loom.v1.SendAndReceiveRequest.MetadataEntryR\bmetadata\x124\n" +
	"\x06policy\x18\x06 \x01(\v2\x1c.loom.v1.CommunicationPolicyR\x06policy\x12'\n" +
	"\x0ftimeout_seconds\x18\a \x01(\x05R\x0etimeoutSeconds\x1a;\n" +
	"\rMetadataEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xce\x02\n" +
	"\x16SendAndReceiveResponse\x12\x1d\n" +
	"\n" +
	"request_id\x18\x01 \x01(\tR\trequestId\x12\x1f\n" +
	"\vresponse_id\x18\x02 \x01(\tR\n" +
	"responseId\x121\n" +
	"\apayload\x18\x03 \x01(\v2\x17.loom.v1.MessagePayloadR\apayload\x12I\n" +
	"\bmetadata\x18\x04 \x03(\v2-.loom.v1.SendAndReceiveResponse.MetadataEntryR\bmetadata\x12\x1c\n" +
	"\ttimestamp\x18\x05 \x01(\x03R\ttimestamp\x12\x1b\n" +
	"\ttimed_out\x18\x06 \x01(\bR\btimedOut\x1a;\n" +
	"\rMetadataEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01*\xaa\x01\n" +
	"\x11CommunicationTier\x12\"\n" +
	"\x1eCOMMUNICATION_TIER_UNSPECIFIED\x10\x00\x12'\n" +
	"#COMMUNICATION_TIER_ALWAYS_REFERENCE\x10\x01\x12#\n" +
	"\x1fCOMMUNICATION_TIER_AUTO_PROMOTE\x10\x02\x12#\n" +
	"\x1fCOMMUNICATION_TIER_ALWAYS_VALUE\x10\x03*\xa9\x02\n" +
	"\rReferenceType\x12\x1e\n" +
	"\x1aREFERENCE_TYPE_UNSPECIFIED\x10\x00\x12 \n" +
	"\x1cREFERENCE_TYPE_SESSION_STATE\x10\x01\x12#\n" +
	"\x1fREFERENCE_TYPE_WORKFLOW_CONTEXT\x10\x02\x12&\n" +
	"\"REFERENCE_TYPE_COLLABORATION_STATE\x10\x03\x12 \n" +
	"\x1cREFERENCE_TYPE_LARGE_PAYLOAD\x10\x04\x12\x1f\n" +
	"\x1bREFERENCE_TYPE_PATTERN_DATA\x10\x05\x12\x1e\n" +
	"\x1aREFERENCE_TYPE_TOOL_RESULT\x10\x06\x12&\n" +
	"\"REFERENCE_TYPE_OBSERVABILITY_TRACE\x10\a*\x84\x01\n" +
	"\x0eReferenceStore\x12\x1f\n" +
	"\x1bREFERENCE_STORE_UNSPECIFIED\x10\x00\x12\x1a\n" +
	"\x16REFERENCE_STORE_MEMORY\x10\x01\x12\x1a\n" +
	"\x16REFERENCE_STORE_SQLITE\x10\x02\x12\x19\n" +
	"\x15REFERENCE_STORE_REDIS\x10\x03B5Z3github.com/teradata-labs/loom/gen/go/loom/v1;loomv1b\x06proto3"

var (
	file_loom_v1_communication_proto_rawDescOnce sync.Once
	file_loom_v1_communication_proto_rawDescData []byte
)

func file_loom_v1_communication_proto_rawDescGZIP() []byte {
	file_loom_v1_communication_proto_rawDescOnce.Do(func() {
		file_loom_v1_communication_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_loom_v1_communication_proto_rawDesc), len(file_loom_v1_communication_proto_rawDesc)))
	})
	return file_loom_v1_communication_proto_rawDescData
}

var file_loom_v1_communication_proto_enumTypes = make([]protoimpl.EnumInfo, 4)
var file_loom_v1_communication_proto_msgTypes = make([]protoimpl.MessageInfo, 16)
var file_loom_v1_communication_proto_goTypes = []any{
	(CommunicationTier)(0),           // 0: loom.v1.CommunicationTier
	(ReferenceType)(0),               // 1: loom.v1.ReferenceType
	(ReferenceStore)(0),              // 2: loom.v1.ReferenceStore
	(PolicyOverride_OverrideType)(0), // 3: loom.v1.PolicyOverride.OverrideType
	(*CommunicationMessage)(nil),     // 4: loom.v1.CommunicationMessage
	(*MessagePayload)(nil),           // 5: loom.v1.MessagePayload
	(*Reference)(nil),                // 6: loom.v1.Reference
	(*PayloadMetadata)(nil),          // 7: loom.v1.PayloadMetadata
	(*CommunicationPolicy)(nil),      // 8: loom.v1.CommunicationPolicy
	(*AutoPromoteConfig)(nil),        // 9: loom.v1.AutoPromoteConfig
	(*PolicyOverride)(nil),           // 10: loom.v1.PolicyOverride
	(*ReferenceStoreStats)(nil),      // 11: loom.v1.ReferenceStoreStats
	(*SendAsyncRequest)(nil),         // 12: loom.v1.SendAsyncRequest
	(*SendAsyncResponse)(nil),        // 13: loom.v1.SendAsyncResponse
	(*SendAndReceiveRequest)(nil),    // 14: loom.v1.SendAndReceiveRequest
	(*SendAndReceiveResponse)(nil),   // 15: loom.v1.SendAndReceiveResponse
	nil,                              // 16: loom.v1.CommunicationPolicy.OverridesEntry
	nil,                              // 17: loom.v1.SendAsyncRequest.MetadataEntry
	nil,                              // 18: loom.v1.SendAndReceiveRequest.MetadataEntry
	nil,                              // 19: loom.v1.SendAndReceiveResponse.MetadataEntry
}
var file_loom_v1_communication_proto_depIdxs = []int32{
	5,  // 0: loom.v1.CommunicationMessage.payload:type_name -> loom.v1.MessagePayload
	8,  // 1: loom.v1.CommunicationMessage.policy:type_name -> loom.v1.CommunicationPolicy
	6,  // 2: loom.v1.MessagePayload.reference:type_name -> loom.v1.Reference
	7,  // 3: loom.v1.MessagePayload.metadata:type_name -> loom.v1.PayloadMetadata
	1,  // 4: loom.v1.Reference.type:type_name -> loom.v1.ReferenceType
	2,  // 5: loom.v1.Reference.store:type_name -> loom.v1.ReferenceStore
	0,  // 6: loom.v1.CommunicationPolicy.tier:type_name -> loom.v1.CommunicationTier
	9,  // 7: loom.v1.CommunicationPolicy.auto_promote:type_name -> loom.v1.AutoPromoteConfig
	16, // 8: loom.v1.CommunicationPolicy.overrides:type_name -> loom.v1.CommunicationPolicy.OverridesEntry
	3,  // 9: loom.v1.PolicyOverride.type:type_name -> loom.v1.PolicyOverride.OverrideType
	5,  // 10: loom.v1.SendAsyncRequest.payload:type_name -> loom.v1.MessagePayload
	17, // 11: loom.v1.SendAsyncRequest.metadata:type_name -> loom.v1.SendAsyncRequest.MetadataEntry
	8,  // 12: loom.v1.SendAsyncRequest.policy:type_name -> loom.v1.CommunicationPolicy
	5,  // 13: loom.v1.SendAndReceiveRequest.payload:type_name -> loom.v1.MessagePayload
	18, // 14: loom.v1.SendAndReceiveRequest.metadata:type_name -> loom.v1.SendAndReceiveRequest.MetadataEntry
	8,  // 15: loom.v1.SendAndReceiveRequest.policy:type_name -> loom.v1.CommunicationPolicy
	5,  // 16: loom.v1.SendAndReceiveResponse.payload:type_name -> loom.v1.MessagePayload
	19, // 17: loom.v1.SendAndReceiveResponse.metadata:type_name -> loom.v1.SendAndReceiveResponse.MetadataEntry
	10, // 18: loom.v1.CommunicationPolicy.OverridesEntry.value:type_name -> loom.v1.PolicyOverride
	19, // [19:19] is the sub-list for method output_type
	19, // [19:19] is the sub-list for method input_type
	19, // [19:19] is the sub-list for extension type_name
	19, // [19:19] is the sub-list for extension extendee
	0,  // [0:19] is the sub-list for field type_name
}

func init() { file_loom_v1_communication_proto_init() }
func file_loom_v1_communication_proto_init() {
	if File_loom_v1_communication_proto != nil {
		return
	}
	file_loom_v1_communication_proto_msgTypes[1].OneofWrappers = []any{
		(*MessagePayload_Value)(nil),
		(*MessagePayload_Reference)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_loom_v1_communication_proto_rawDesc), len(file_loom_v1_communication_proto_rawDesc)),
			NumEnums:      4,
			NumMessages:   16,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_loom_v1_communication_proto_goTypes,
		DependencyIndexes: file_loom_v1_communication_proto_depIdxs,
		EnumInfos:         file_loom_v1_communication_proto_enumTypes,
		MessageInfos:      file_loom_v1_communication_proto_msgTypes,
	}.Build()
	File_loom_v1_communication_proto = out.File
	file_loom_v1_communication_proto_goTypes = nil
	file_loom_v1_communication_proto_depIdxs = nil
}

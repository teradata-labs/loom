// Copyright Â© 2026 Teradata Corporation - All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.

package docker

import (
	"context"
	"fmt"
	"strings"

	loomv1 "github.com/teradata-labs/loom/gen/go/loom/v1"
	"github.com/teradata-labs/loom/pkg/fabric"
	"go.uber.org/zap"
)

// DockerBackend implements fabric.ExecutionBackend for Docker-based execution.
//
// Enables running arbitrary code in isolated Docker containers:
//   - Python scripts (with pip packages)
//   - Node.js applications (with npm packages)
//   - Custom binaries (Rust, Go, Ruby, etc.)
//   - MCP servers (Teradata, GitHub, filesystem, etc.)
//
// Features:
//   - Container pooling and reuse (50-100ms warm start vs 1-3s cold start)
//   - Resource limits (CPU, memory, storage, PIDs)
//   - Security hardening (read-only rootfs, capability dropping, non-root)
//   - Package caching (pip, npm) for fast installs
//   - Container rotation (time-based and execution-based)
//   - Health checks and auto-cleanup
//
// Use Cases:
//
//  1. **Python Agent**: Run Python code generated by LLM
//     - Install packages: numpy, pandas, requests
//     - Execute: data analysis, API calls, file processing
//
//  2. **MCP Server Host**: Run MCP servers in containers
//     - Teradata MCP: Database queries via JSON-RPC
//     - GitHub MCP: GitHub API access
//     - Filesystem MCP: Safe file operations
//
//  3. **Multi-Language Toolchain**: Support non-SQL domains
//     - Rust: Compile and run Rust code
//     - Node.js: Execute JavaScript/TypeScript
//     - Ruby: Run Ruby scripts
//
// Thread Safety: All methods are thread-safe.
type DockerBackend struct {
	config   *loomv1.DockerBackendConfig
	executor *DockerExecutor
	logger   *zap.Logger
}

// DockerBackendConfig wraps proto config and adds Go-specific fields.
type DockerBackendConfig struct {
	// Config is the proto configuration
	Config *loomv1.DockerBackendConfig

	// DockerHost is the Docker daemon endpoint (default: "unix:///var/run/docker.sock")
	DockerHost string

	// Scheduler is the container scheduler (optional, created if nil)
	Scheduler ContainerScheduler

	// Logger is the zap logger (optional, created if nil)
	Logger *zap.Logger
}

// NewDockerBackend creates a new Docker backend.
func NewDockerBackend(ctx context.Context, config DockerBackendConfig) (*DockerBackend, error) {
	if config.Config == nil {
		return nil, fmt.Errorf("docker backend config is nil")
	}

	// Create logger if not provided
	logger := config.Logger
	if logger == nil {
		var err error
		logger, err = zap.NewProduction()
		if err != nil {
			return nil, fmt.Errorf("failed to create logger: %w", err)
		}
	}

	// Detect Docker host if not explicitly provided
	if config.DockerHost == "" {
		config.DockerHost = detectDockerHost()
	}

	logger.Info("creating docker backend",
		zap.String("runtime_type", config.Config.RuntimeType.String()),
		zap.String("docker_host", config.DockerHost),
	)

	// Create scheduler if not provided
	scheduler := config.Scheduler
	if scheduler == nil {
		localScheduler, err := NewLocalScheduler(ctx, LocalSchedulerConfig{
			DockerHost: config.DockerHost,
			Logger:     logger.Named("scheduler"),
		})
		if err != nil {
			return nil, fmt.Errorf("failed to create scheduler: %w", err)
		}
		scheduler = localScheduler
	}

	// Create executor
	executor, err := NewDockerExecutor(ctx, DockerExecutorConfig{
		DockerHost: config.DockerHost,
		Scheduler:  scheduler,
		Logger:     logger.Named("executor"),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to create executor: %w", err)
	}

	logger.Info("docker backend created successfully")

	return &DockerBackend{
		config:   config.Config,
		executor: executor,
		logger:   logger,
	}, nil
}

// Name implements fabric.ExecutionBackend.Name.
func (db *DockerBackend) Name() string {
	// Include runtime type in name for multi-backend setups
	runtimeName := db.config.RuntimeType.String()
	return fmt.Sprintf("docker_%s", strings.ToLower(strings.TrimPrefix(runtimeName, "RUNTIME_TYPE_")))
}

// ExecuteQuery implements fabric.ExecutionBackend.ExecuteQuery.
//
// For Docker backend:
//   - query: Command to execute (e.g., "python script.py", "node app.js")
//   - result: Command output (stdout/stderr, exit code)
//
// Query Format:
//   - Simple command: "python -c 'print(2+2)'"
//   - Script file: "python /workspace/script.py"
//   - With args: "node app.js --input data.json"
//
// Result Format:
//   - Type: "command_output"
//   - Data: {"stdout": "...", "stderr": "...", "exit_code": 0}
//   - ExecutionStats: Duration, resource usage
func (db *DockerBackend) ExecuteQuery(ctx context.Context, query string) (*fabric.QueryResult, error) {
	if query == "" {
		db.logger.Error("empty query provided")
		return nil, fmt.Errorf("query is empty")
	}

	db.logger.Info("executing query", zap.String("query", query))

	// Parse query into command
	command, err := parseCommand(query)
	if err != nil {
		db.logger.Error("failed to parse command",
			zap.String("query", query),
			zap.Error(err),
		)
		return nil, fmt.Errorf("failed to parse command: %w", err)
	}

	db.logger.Debug("parsed command", zap.Strings("command", command))

	// Execute in Docker container
	resp, err := db.executor.Execute(ctx, &loomv1.ExecuteRequest{
		RuntimeType: db.config.RuntimeType,
		Config:      db.config,
		Command:     command,
	})
	if err != nil {
		db.logger.Error("docker execution failed",
			zap.Strings("command", command),
			zap.Error(err),
		)
		return nil, fmt.Errorf("docker execution failed: %w", err)
	}

	db.logger.Info("execution completed",
		zap.String("container_id", resp.ContainerId),
		zap.Int32("exit_code", resp.ExitCode),
		zap.Int64("duration_ms", resp.DurationMs),
		zap.Bool("was_created", resp.ContainerCreated),
	)

	// Build result
	result := &fabric.QueryResult{
		Type: "command_output",
		Data: map[string]interface{}{
			"stdout":       string(resp.Stdout),
			"stderr":       string(resp.Stderr),
			"exit_code":    resp.ExitCode,
			"container_id": resp.ContainerId,
			"was_created":  resp.ContainerCreated,
		},
		ExecutionStats: fabric.ExecutionStats{
			DurationMs: resp.DurationMs,
		},
	}

	// If exit code is non-zero, include stderr in error (but still return result)
	if resp.ExitCode != 0 {
		db.logger.Warn("command exited with non-zero code",
			zap.Int32("exit_code", resp.ExitCode),
			zap.String("stderr", string(resp.Stderr)),
		)
		result.Metadata = map[string]interface{}{
			"error": fmt.Sprintf("command exited with code %d: %s", resp.ExitCode, string(resp.Stderr)),
		}
	}

	return result, nil
}

// GetSchema implements fabric.ExecutionBackend.GetSchema.
//
// For Docker backend:
//   - resource: "python_packages", "node_packages", "container_info"
//   - schema: Available packages, container configuration
func (db *DockerBackend) GetSchema(ctx context.Context, resource string) (*fabric.Schema, error) {
	db.logger.Debug("getting schema", zap.String("resource", resource))

	switch resource {
	case "runtime_info":
		return db.getRuntimeInfoSchema(), nil
	case "container_config":
		return db.getContainerConfigSchema(), nil
	default:
		db.logger.Warn("unknown resource requested", zap.String("resource", resource))
		return nil, fmt.Errorf("unknown resource: %s", resource)
	}
}

// ListResources implements fabric.ExecutionBackend.ListResources.
//
// For Docker backend:
//   - Lists available resources (runtime_info, container_config)
func (db *DockerBackend) ListResources(ctx context.Context, filters map[string]string) ([]fabric.Resource, error) {
	return []fabric.Resource{
		{
			Name:        "runtime_info",
			Type:        "metadata",
			Description: "Runtime configuration (Python version, packages, etc.)",
		},
		{
			Name:        "container_config",
			Type:        "metadata",
			Description: "Container configuration (resource limits, volumes, etc.)",
		},
	}, nil
}

// GetMetadata implements fabric.ExecutionBackend.GetMetadata.
//
// For Docker backend:
//   - Returns runtime metadata (Python version, installed packages, etc.)
func (db *DockerBackend) GetMetadata(ctx context.Context, resource string) (map[string]interface{}, error) {
	db.logger.Debug("getting metadata", zap.String("resource", resource))

	switch resource {
	case "runtime_info":
		return db.getRuntimeInfoMetadata(), nil
	case "container_config":
		return db.getContainerConfigMetadata(), nil
	default:
		db.logger.Warn("unknown resource requested for metadata", zap.String("resource", resource))
		return nil, fmt.Errorf("unknown resource: %s", resource)
	}
}

// Ping implements fabric.ExecutionBackend.Ping.
func (db *DockerBackend) Ping(ctx context.Context) error {
	db.logger.Debug("ping received")

	// Check executor health (Docker daemon + scheduler)
	if db.executor == nil {
		db.logger.Error("executor not initialized")
		return fmt.Errorf("executor not initialized")
	}

	if err := db.executor.Health(ctx); err != nil {
		db.logger.Error("executor health check failed", zap.Error(err))
		return fmt.Errorf("backend health check failed: %w", err)
	}

	db.logger.Debug("ping successful - all health checks passed")
	return nil
}

// Capabilities implements fabric.ExecutionBackend.Capabilities.
func (db *DockerBackend) Capabilities() *fabric.Capabilities {
	return &fabric.Capabilities{
		SupportsTransactions: false, // Docker containers don't support transactions
		SupportsConcurrency:  true,  // Multiple containers can run concurrently
		SupportsStreaming:    true,  // Stdout/stderr streaming support
		MaxConcurrentOps:     10,    // Concurrent container limit (configurable)
		SupportedOperations: []string{
			"execute",          // Execute command
			"install_packages", // Install packages (pip, npm)
			"get_logs",         // Get container logs
		},
		Features: map[string]bool{
			"container_reuse":    true,
			"package_caching":    true,
			"resource_limits":    true,
			"security_hardening": true,
		},
		Limits: map[string]int64{
			"max_execution_time_seconds": 3600,  // 1 hour max
			"max_memory_mb":              16384, // 16GB max
			"max_cpu_cores":              8,     // 8 cores max
		},
	}
}

// ExecuteCustomOperation implements fabric.ExecutionBackend.ExecuteCustomOperation.
//
// Supported operations:
//   - "install_packages": Install runtime-specific packages
//   - "get_logs": Get container logs
//   - "list_containers": List all managed containers
func (db *DockerBackend) ExecuteCustomOperation(ctx context.Context, op string, params map[string]interface{}) (interface{}, error) {
	db.logger.Info("executing custom operation", zap.String("operation", op))

	switch op {
	case "install_packages":
		return db.installPackages(ctx, params)
	case "get_logs":
		return db.getContainerLogs(ctx, params)
	case "list_containers":
		return db.listContainers(ctx, params)
	default:
		db.logger.Error("unsupported operation", zap.String("operation", op))
		return nil, fmt.Errorf("unsupported operation: %s", op)
	}
}

// Close implements fabric.ExecutionBackend.Close.
func (db *DockerBackend) Close() error {
	db.logger.Info("closing docker backend")

	if db.executor != nil {
		if err := db.executor.Close(); err != nil {
			db.logger.Error("failed to close executor", zap.Error(err))
			return err
		}
	}

	db.logger.Info("docker backend closed successfully")
	return nil
}

// Helper methods

func (db *DockerBackend) getRuntimeInfoSchema() *fabric.Schema {
	return &fabric.Schema{
		Name: "runtime_info",
		Type: "metadata",
		Fields: []fabric.Field{
			{Name: "runtime_type", Type: "string", Description: "Runtime type (python, node, custom)"},
			{Name: "version", Type: "string", Description: "Runtime version"},
			{Name: "packages", Type: "array", Description: "Installed packages"},
		},
	}
}

func (db *DockerBackend) getContainerConfigSchema() *fabric.Schema {
	return &fabric.Schema{
		Name: "container_config",
		Type: "metadata",
		Fields: []fabric.Field{
			{Name: "cpu_cores", Type: "float", Description: "CPU limit"},
			{Name: "memory_mb", Type: "int", Description: "Memory limit"},
			{Name: "working_dir", Type: "string", Description: "Working directory"},
		},
	}
}

func (db *DockerBackend) getRuntimeInfoMetadata() map[string]interface{} {
	metadata := map[string]interface{}{
		"runtime_type": db.config.RuntimeType.String(),
	}

	// Add runtime-specific info
	switch db.config.RuntimeType {
	case loomv1.RuntimeType_RUNTIME_TYPE_PYTHON:
		if pythonConfig := db.config.GetPython(); pythonConfig != nil {
			metadata["python_version"] = pythonConfig.PythonVersion
			metadata["preinstalled_packages"] = pythonConfig.PreinstallPackages
		}
	case loomv1.RuntimeType_RUNTIME_TYPE_NODE:
		if nodeConfig := db.config.GetNode(); nodeConfig != nil {
			metadata["node_version"] = nodeConfig.NodeVersion
			metadata["preinstalled_packages"] = nodeConfig.PreinstallPackages
		}
	}

	return metadata
}

func (db *DockerBackend) getContainerConfigMetadata() map[string]interface{} {
	metadata := map[string]interface{}{
		"working_dir": db.config.WorkingDir,
	}

	if limits := db.config.ResourceLimits; limits != nil {
		metadata["cpu_cores"] = limits.CpuCores
		metadata["memory_mb"] = limits.MemoryMb
		metadata["execution_timeout_seconds"] = limits.ExecutionTimeoutSeconds
	}

	return metadata
}

func (db *DockerBackend) installPackages(ctx context.Context, params map[string]interface{}) (interface{}, error) {
	packagesRaw, ok := params["packages"]
	if !ok {
		db.logger.Error("packages parameter is required")
		return nil, fmt.Errorf("packages parameter is required")
	}

	packages, ok := packagesRaw.([]string)
	if !ok {
		db.logger.Error("packages must be a string array", zap.Any("packages", packagesRaw))
		return nil, fmt.Errorf("packages must be a string array")
	}

	db.logger.Info("installing packages", zap.Strings("packages", packages))

	// Build install command based on runtime
	var installCmd []string
	switch db.config.RuntimeType {
	case loomv1.RuntimeType_RUNTIME_TYPE_PYTHON:
		installCmd = append([]string{"pip", "install"}, packages...)
	case loomv1.RuntimeType_RUNTIME_TYPE_NODE:
		installCmd = append([]string{"npm", "install", "-g"}, packages...)
	default:
		db.logger.Error("install_packages not supported for runtime",
			zap.String("runtime", db.config.RuntimeType.String()),
		)
		return nil, fmt.Errorf("install_packages not supported for runtime: %v", db.config.RuntimeType)
	}

	// Execute install command
	resp, err := db.executor.Execute(ctx, &loomv1.ExecuteRequest{
		RuntimeType: db.config.RuntimeType,
		Config:      db.config,
		Command:     installCmd,
	})
	if err != nil {
		db.logger.Error("failed to install packages",
			zap.Strings("packages", packages),
			zap.Error(err),
		)
		return nil, fmt.Errorf("failed to install packages: %w", err)
	}

	db.logger.Info("packages installed successfully",
		zap.Strings("packages", packages),
		zap.Int32("exit_code", resp.ExitCode),
	)

	return map[string]interface{}{
		"stdout":    string(resp.Stdout),
		"stderr":    string(resp.Stderr),
		"exit_code": resp.ExitCode,
	}, nil
}

func (db *DockerBackend) getContainerLogs(ctx context.Context, params map[string]interface{}) (interface{}, error) {
	db.logger.Info("getting container logs", zap.Any("params", params))

	// Extract container ID
	containerIDRaw, ok := params["container_id"]
	if !ok {
		db.logger.Error("container_id parameter is required")
		return nil, fmt.Errorf("container_id parameter is required")
	}

	containerID, ok := containerIDRaw.(string)
	if !ok {
		db.logger.Error("container_id must be a string", zap.Any("container_id", containerIDRaw))
		return nil, fmt.Errorf("container_id must be a string")
	}

	// Extract optional parameters
	tail := 100 // Default: last 100 lines
	if tailRaw, ok := params["tail"]; ok {
		if tailFloat, ok := tailRaw.(float64); ok {
			tail = int(tailFloat)
		}
	}

	timestamps := false // Default: no timestamps
	if timestampsRaw, ok := params["timestamps"]; ok {
		if timestampsBool, ok := timestampsRaw.(bool); ok {
			timestamps = timestampsBool
		}
	}

	// Get logs from executor
	logs, err := db.executor.GetContainerLogs(ctx, containerID, tail, timestamps)
	if err != nil {
		db.logger.Error("failed to get container logs",
			zap.String("container_id", containerID),
			zap.Error(err),
		)
		return nil, fmt.Errorf("failed to get container logs: %w", err)
	}

	db.logger.Info("container logs retrieved",
		zap.String("container_id", containerID),
		zap.Int("log_size", len(logs)),
	)

	return map[string]interface{}{
		"container_id": containerID,
		"logs":         logs,
		"tail":         tail,
		"timestamps":   timestamps,
	}, nil
}

func (db *DockerBackend) listContainers(ctx context.Context, params map[string]interface{}) (interface{}, error) {
	db.logger.Info("listing containers", zap.Any("params", params))

	// Build filters from params
	filters := make(map[string]string)
	if tenantID, ok := params["tenant_id"].(string); ok {
		filters["tenant_id"] = tenantID
	}
	if runtimeType, ok := params["runtime_type"].(string); ok {
		filters["runtime_type"] = runtimeType
	}
	if status, ok := params["status"].(string); ok {
		filters["status"] = status
	}

	// Get scheduler from executor and list containers
	containers, err := db.executor.scheduler.ListContainers(ctx, filters)
	if err != nil {
		db.logger.Error("failed to list containers",
			zap.Any("filters", filters),
			zap.Error(err),
		)
		return nil, fmt.Errorf("failed to list containers: %w", err)
	}

	db.logger.Info("containers listed",
		zap.Int("count", len(containers)),
		zap.Any("filters", filters),
	)

	return map[string]interface{}{
		"containers": containers,
		"count":      len(containers),
		"filters":    filters,
	}, nil
}

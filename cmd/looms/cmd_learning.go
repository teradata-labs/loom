// Copyright 2026 Teradata
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package main

import (
	"context"
	"fmt"
	"os"
	"os/signal"
	"strings"
	"time"

	"github.com/spf13/cobra"
	loomv1 "github.com/teradata-labs/loom/gen/go/loom/v1"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
)

var learningCmd = &cobra.Command{
	Use:   "learning",
	Short: "Manage learning agent operations",
	Long: `Manage the Learning Agent (Burler) - self-improving agent system.

The learning agent monitors pattern effectiveness, generates improvement
proposals, and applies changes with safety mechanisms (circuit breakers,
autonomy levels, rollback support).

Use these commands to analyze patterns, review proposals, apply improvements,
and monitor real-time metrics.`,
}

var learningAnalyzeCmd = &cobra.Command{
	Use:   "analyze",
	Short: "Analyze pattern effectiveness",
	Long: `Analyze pattern effectiveness across agents and domains.

Generates insights on pattern performance, including success rates,
cost metrics, latency, and error patterns. Provides recommendations
for pattern improvements (PROMOTE, KEEP, DEMOTE, REMOVE, INVESTIGATE).

Examples:
  # Analyze all patterns
  looms learning analyze

  # Analyze patterns for specific domain
  looms learning analyze --domain=sql

  # Analyze patterns for specific agent
  looms learning analyze --agent=sql-optimizer-abc123

  # Custom time window (hours)
  looms learning analyze --domain=sql --window=48`,
	Run: runLearningAnalyze,
}

var learningProposalsCmd = &cobra.Command{
	Use:   "proposals",
	Short: "List improvement proposals",
	Long: `List improvement proposals generated by the learning agent.

Shows pending, approved, applied, or failed improvements with details
on expected benefits (cost reduction, quality gain, latency improvement).

Examples:
  # List all pending proposals
  looms learning proposals

  # Filter by status
  looms learning proposals --status=pending
  looms learning proposals --status=applied

  # Filter by domain
  looms learning proposals --domain=sql

  # Filter by agent
  looms learning proposals --agent=sql-optimizer-abc123

  # Limit results
  looms learning proposals --limit=10`,
	Run: runLearningProposals,
}

var learningApplyCmd = &cobra.Command{
	Use:   "apply [improvement-id]",
	Short: "Apply an improvement proposal",
	Long: `Apply a pending improvement proposal.

Marks the improvement as applied and triggers pattern hot-reload
to activate the new pattern version. Respects autonomy level:
  - Manual: Requires explicit apply command
  - Human Approval: Applies after human review
  - Full Auto: Applies automatically (circuit breaker protected)

Examples:
  # Apply specific improvement
  looms learning apply abc123-def456-ghi789

  # Apply with custom timeout
  looms learning apply abc123-def456-ghi789 --timeout=60`,
	Args: cobra.ExactArgs(1),
	Run:  runLearningApply,
}

var learningRollbackCmd = &cobra.Command{
	Use:   "rollback [improvement-id]",
	Short: "Rollback an applied improvement",
	Long: `Rollback an applied improvement to its previous state.

Marks the improvement as rolled back and triggers pattern hot-reload
to restore the previous pattern version.

Examples:
  # Rollback specific improvement
  looms learning rollback abc123-def456-ghi789

  # Rollback with custom timeout
  looms learning rollback abc123-def456-ghi789 --timeout=60`,
	Args: cobra.ExactArgs(1),
	Run:  runLearningRollback,
}

var learningHistoryCmd = &cobra.Command{
	Use:   "history",
	Short: "Get improvement history",
	Long: `Get history of all improvements (pending, applied, rolled back, failed).

Shows the complete audit trail of learning agent decisions with
timestamps, status transitions, and effectiveness metrics.

Examples:
  # Get all improvement history
  looms learning history

  # Filter by agent
  looms learning history --agent=sql-optimizer-abc123

  # Filter by domain
  looms learning history --domain=sql

  # Filter by status
  looms learning history --status=applied

  # Limit results
  looms learning history --limit=50`,
	Run: runLearningHistory,
}

var learningStreamCmd = &cobra.Command{
	Use:   "stream",
	Short: "Stream real-time pattern metrics",
	Long: `Stream real-time pattern effectiveness metrics from the MessageBus.

Displays live updates as patterns are used, including success rates,
cost, latency, and error types. Useful for monitoring pattern
performance during development or debugging.

Examples:
  # Stream all pattern metrics
  looms learning stream

  # Stream for specific domain
  looms learning stream --domain=sql

  # Stream for specific agent
  looms learning stream --agent=sql-optimizer-abc123

Press Ctrl+C to stop streaming.`,
	Run: runLearningStream,
}

var learningTuneCmd = &cobra.Command{
	Use:   "tune",
	Short: "Automatically tune pattern priorities",
	Long: `Automatically tune pattern priorities based on effectiveness analysis.

Analyzes pattern performance metrics (success rate, cost, latency) and
adjusts pattern priorities to optimize for your chosen objectives.
Supports conservative, moderate, and aggressive tuning strategies.

The tuning algorithm uses multi-objective optimization with configurable
weights for cost, quality, and latency. Higher priority patterns are
used more frequently by agents.

Examples:
  # Dry run (preview changes without applying)
  looms learning tune --domain=sql --dry-run

  # Tune SQL patterns with moderate strategy
  looms learning tune --domain=sql --strategy=moderate --library=/path/to/patterns

  # Aggressive tuning optimizing for quality
  looms learning tune --domain=sql --strategy=aggressive --quality-weight=0.8 --cost-weight=0.2

  # Conservative tuning for all domains
  looms learning tune --strategy=conservative --library=/path/to/patterns

  # Tune specific agent's patterns
  looms learning tune --agent=sql-optimizer-abc123 --library=/path/to/patterns`,
	Run: runLearningTune,
}

var (
	learningServer         string
	learningTimeout        int
	learningDomain         string
	learningAgent          string
	learningWindow         int
	learningStatus         string
	learningLimit          int32
	learningTuneStrategy   string
	learningTuneDryRun     bool
	learningTuneLibrary    string
	learningTuneCostWeight float64
	learningTuneQualWeight float64
	learningTuneLatWeight  float64

	// Judge dimension weights (new, preferred)
	learningTuneDimQuality   float64
	learningTuneDimSafety    float64
	learningTuneDimCost      float64
	learningTuneDimDomain    float64
	learningTuneDimPerf      float64
	learningTuneDimUsability float64
)

func init() {
	rootCmd.AddCommand(learningCmd)
	learningCmd.AddCommand(learningAnalyzeCmd)
	learningCmd.AddCommand(learningProposalsCmd)
	learningCmd.AddCommand(learningApplyCmd)
	learningCmd.AddCommand(learningRollbackCmd)
	learningCmd.AddCommand(learningHistoryCmd)
	learningCmd.AddCommand(learningStreamCmd)
	learningCmd.AddCommand(learningTuneCmd)

	// Global learning flags
	for _, cmd := range []*cobra.Command{
		learningAnalyzeCmd,
		learningProposalsCmd,
		learningApplyCmd,
		learningRollbackCmd,
		learningHistoryCmd,
		learningStreamCmd,
		learningTuneCmd,
	} {
		cmd.Flags().StringVar(&learningServer, "server", "localhost:60051", "Loom server address")
		cmd.Flags().IntVar(&learningTimeout, "timeout", 30, "Request timeout in seconds")
	}

	// Analyze command flags
	learningAnalyzeCmd.Flags().StringVar(&learningDomain, "domain", "", "Filter by domain (optional)")
	learningAnalyzeCmd.Flags().StringVar(&learningAgent, "agent", "", "Filter by agent ID (optional)")
	learningAnalyzeCmd.Flags().IntVar(&learningWindow, "window", 24, "Time window in hours")

	// Proposals command flags
	learningProposalsCmd.Flags().StringVar(&learningDomain, "domain", "", "Filter by domain (optional)")
	learningProposalsCmd.Flags().StringVar(&learningAgent, "agent", "", "Filter by agent ID (optional)")
	learningProposalsCmd.Flags().StringVar(&learningStatus, "status", "pending", "Filter by status (pending, applied, rolled_back, failed)")
	learningProposalsCmd.Flags().Int32Var(&learningLimit, "limit", 20, "Maximum number of proposals to show")

	// History command flags
	learningHistoryCmd.Flags().StringVar(&learningDomain, "domain", "", "Filter by domain (optional)")
	learningHistoryCmd.Flags().StringVar(&learningAgent, "agent", "", "Filter by agent ID (optional)")
	learningHistoryCmd.Flags().StringVar(&learningStatus, "status", "", "Filter by status (optional)")
	learningHistoryCmd.Flags().Int32Var(&learningLimit, "limit", 50, "Maximum number of history entries to show")

	// Stream command flags
	learningStreamCmd.Flags().StringVar(&learningDomain, "domain", "", "Filter by domain (optional)")
	learningStreamCmd.Flags().StringVar(&learningAgent, "agent", "", "Filter by agent ID (optional)")

	// Tune command flags
	learningTuneCmd.Flags().StringVar(&learningDomain, "domain", "", "Filter by domain (optional)")
	learningTuneCmd.Flags().StringVar(&learningAgent, "agent", "", "Filter by agent ID (optional)")
	learningTuneCmd.Flags().StringVar(&learningTuneStrategy, "strategy", "moderate", "Tuning strategy (conservative, moderate, aggressive)")
	learningTuneCmd.Flags().BoolVar(&learningTuneDryRun, "dry-run", false, "Preview changes without applying them")
	learningTuneCmd.Flags().StringVar(&learningTuneLibrary, "library", "", "Path to pattern library YAML files (required)")

	// Legacy weights (for patterns without judge scores)
	learningTuneCmd.Flags().Float64Var(&learningTuneCostWeight, "cost-weight", 0.0, "Legacy: Optimization weight for cost (0.0-1.0)")
	learningTuneCmd.Flags().Float64Var(&learningTuneQualWeight, "quality-weight", 0.0, "Legacy: Optimization weight for quality (0.0-1.0)")
	learningTuneCmd.Flags().Float64Var(&learningTuneLatWeight, "latency-weight", 0.0, "Legacy: Optimization weight for latency (0.0-1.0)")

	// Judge dimension weights (preferred - uses multi-dimensional judge scores)
	learningTuneCmd.Flags().Float64Var(&learningTuneDimQuality, "dimension-quality", 0.0, "Judge dimension weight for quality (0.0-1.0)")
	learningTuneCmd.Flags().Float64Var(&learningTuneDimSafety, "dimension-safety", 0.0, "Judge dimension weight for safety (0.0-1.0)")
	learningTuneCmd.Flags().Float64Var(&learningTuneDimCost, "dimension-cost", 0.0, "Judge dimension weight for cost (0.0-1.0)")
	learningTuneCmd.Flags().Float64Var(&learningTuneDimDomain, "dimension-domain", 0.0, "Judge dimension weight for domain compliance (0.0-1.0)")
	learningTuneCmd.Flags().Float64Var(&learningTuneDimPerf, "dimension-performance", 0.0, "Judge dimension weight for performance (0.0-1.0)")
	learningTuneCmd.Flags().Float64Var(&learningTuneDimUsability, "dimension-usability", 0.0, "Judge dimension weight for usability (0.0-1.0)")

	_ = learningTuneCmd.MarkFlagRequired("library")
}

// createLearningClient creates a gRPC client for the LearningAgentService
func createLearningClient(serverAddr string) (loomv1.LearningAgentServiceClient, *grpc.ClientConn, error) {
	conn, err := grpc.NewClient(
		serverAddr,
		grpc.WithTransportCredentials(insecure.NewCredentials()),
	)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to connect to %s: %w", serverAddr, err)
	}

	client := loomv1.NewLearningAgentServiceClient(conn)
	return client, conn, nil
}

func runLearningAnalyze(cmd *cobra.Command, args []string) {
	// Create client
	client, conn, err := createLearningClient(learningServer)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error connecting to server: %v\n", err)
		os.Exit(1)
	}
	defer conn.Close()

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), time.Duration(learningTimeout)*time.Second)
	defer cancel()

	// Build request
	req := &loomv1.AnalyzePatternEffectivenessRequest{
		Domain:      learningDomain,
		AgentId:     learningAgent,
		WindowHours: int64(learningWindow),
	}

	// Call analyze
	fmt.Printf("ðŸ” Analyzing pattern effectiveness...\n")
	if learningDomain != "" {
		fmt.Printf("   Domain: %s\n", learningDomain)
	}
	if learningAgent != "" {
		fmt.Printf("   Agent: %s\n", learningAgent)
	}
	fmt.Printf("   Time window: %d hours\n\n", learningWindow)

	resp, err := client.AnalyzePatternEffectiveness(ctx, req)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error analyzing patterns: %v\n", err)
		os.Exit(1)
	}

	// Display results
	if len(resp.Patterns) == 0 {
		fmt.Println("No pattern metrics available. Run agents with patterns to collect metrics.")
		return
	}

	fmt.Printf("ðŸ“Š Pattern Analysis (%d patterns analyzed)\n", len(resp.Patterns))
	fmt.Println(strings.Repeat("â”€", 80))

	for _, pattern := range resp.Patterns {
		// Pattern header
		fmt.Printf("\nðŸŽ¯ %s (variant: %s)\n", pattern.PatternName, pattern.Variant)
		fmt.Printf("   Domain: %s\n", pattern.Domain)

		// Metrics
		fmt.Printf("   Usage: %d total (%d success, %d failures)\n",
			pattern.TotalUsages, pattern.SuccessCount, pattern.FailureCount)
		fmt.Printf("   Success Rate: %.1f%%\n", pattern.SuccessRate*100)
		fmt.Printf("   Avg Cost: $%.4f | Avg Latency: %dms\n",
			pattern.AvgCostUsd, pattern.AvgLatencyMs)

		// Recommendation
		var icon string
		switch pattern.Recommendation {
		case loomv1.PatternRecommendation_PATTERN_PROMOTE:
			icon = "â¬†ï¸ "
		case loomv1.PatternRecommendation_PATTERN_KEEP:
			icon = "âœ…"
		case loomv1.PatternRecommendation_PATTERN_DEMOTE:
			icon = "â¬‡ï¸ "
		case loomv1.PatternRecommendation_PATTERN_REMOVE:
			icon = "âŒ"
		case loomv1.PatternRecommendation_PATTERN_INVESTIGATE:
			icon = "ðŸ”"
		default:
			icon = "â“"
		}
		fmt.Printf("   Recommendation: %s %s (confidence: %.1f%%)\n",
			icon, pattern.Recommendation.String(), pattern.Confidence*100)

		// Error types
		if len(pattern.ErrorTypes) > 0 {
			fmt.Printf("   Error types: ")
			errorStrs := []string{}
			for errorType, count := range pattern.ErrorTypes {
				errorStrs = append(errorStrs, fmt.Sprintf("%s(%d)", errorType, count))
			}
			fmt.Printf("%s\n", strings.Join(errorStrs, ", "))
		}
	}

	fmt.Println(strings.Repeat("â”€", 80))
	fmt.Printf("\nâœ… Analysis complete. Use 'looms learning proposals' to see improvement suggestions.\n")
}

func runLearningProposals(cmd *cobra.Command, args []string) {
	// Create client
	client, conn, err := createLearningClient(learningServer)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error connecting to server: %v\n", err)
		os.Exit(1)
	}
	defer conn.Close()

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), time.Duration(learningTimeout)*time.Second)
	defer cancel()

	// Parse status
	var statusFilter loomv1.ImprovementStatus
	switch strings.ToLower(learningStatus) {
	case "pending":
		statusFilter = loomv1.ImprovementStatus_IMPROVEMENT_PENDING
	case "applied":
		statusFilter = loomv1.ImprovementStatus_IMPROVEMENT_APPLIED
	case "rolled_back", "rollback":
		statusFilter = loomv1.ImprovementStatus_IMPROVEMENT_ROLLED_BACK
	case "rejected":
		statusFilter = loomv1.ImprovementStatus_IMPROVEMENT_REJECTED
	default:
		statusFilter = loomv1.ImprovementStatus_IMPROVEMENT_PENDING
	}

	// Build request
	req := &loomv1.GenerateImprovementsRequest{
		Domain:       learningDomain,
		AgentId:      learningAgent,
		MaxProposals: learningLimit,
	}

	// Call generate improvements
	fmt.Printf("ðŸ“‹ Listing improvement proposals...\n")
	if learningDomain != "" {
		fmt.Printf("   Domain: %s\n", learningDomain)
	}
	if learningAgent != "" {
		fmt.Printf("   Agent: %s\n", learningAgent)
	}
	fmt.Printf("   Status: %s\n", learningStatus)
	fmt.Printf("   Limit: %d\n\n", learningLimit)

	resp, err := client.GenerateImprovements(ctx, req)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error generating improvements: %v\n", err)
		os.Exit(1)
	}

	// Filter by status
	var filtered []*loomv1.Improvement
	for _, improvement := range resp.Improvements {
		if improvement.Status == statusFilter {
			filtered = append(filtered, improvement)
		}
	}

	if len(filtered) == 0 {
		fmt.Printf("No %s improvements found.\n", learningStatus)
		fmt.Println("\nTip: Run 'looms learning analyze' to generate new improvement proposals.")
		return
	}

	// Display proposals
	fmt.Printf("ðŸ’¡ Improvement Proposals (%d found)\n", len(filtered))
	fmt.Println(strings.Repeat("â”€", 80))

	for i, improvement := range filtered {
		fmt.Printf("\n[%d] ID: %s\n", i+1, improvement.Id)
		fmt.Printf("    Pattern: %s\n", improvement.TargetPattern)
		fmt.Printf("    Domain: %s | Agent: %s\n", improvement.Domain, improvement.TargetAgentId)
		fmt.Printf("    Status: %s\n", improvement.Status.String())

		// Expected benefits
		if improvement.Details != nil {
			fmt.Printf("    Expected Benefits:\n")
			fmt.Printf("      - Success Rate Delta: %+.1f%%\n", improvement.Details.ExpectedSuccessRateDelta*100)
			fmt.Printf("      - Cost Delta: $%.4f\n", improvement.Details.ExpectedCostDeltaUsd)
			fmt.Printf("      - Latency Delta: %+dms\n", improvement.Details.ExpectedLatencyDeltaMs)
			fmt.Printf("      - Confidence: %.1f%%\n", improvement.Confidence*100)

			if improvement.Details.Rationale != "" {
				fmt.Printf("    Rationale: %s\n", improvement.Details.Rationale)
			}
		}

		// Apply command hint
		if improvement.Status == loomv1.ImprovementStatus_IMPROVEMENT_PENDING {
			fmt.Printf("    ðŸ’¡ Apply: looms learning apply %s\n", improvement.Id)
		}
	}

	fmt.Println(strings.Repeat("â”€", 80))

	pendingCount := 0
	for _, imp := range filtered {
		if imp.Status == loomv1.ImprovementStatus_IMPROVEMENT_PENDING {
			pendingCount++
		}
	}
	if pendingCount > 0 {
		fmt.Printf("\nâœ¨ %d pending improvements ready to apply.\n", pendingCount)
	}
}

func runLearningApply(cmd *cobra.Command, args []string) {
	improvementID := args[0]

	// Create client
	client, conn, err := createLearningClient(learningServer)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error connecting to server: %v\n", err)
		os.Exit(1)
	}
	defer conn.Close()

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), time.Duration(learningTimeout)*time.Second)
	defer cancel()

	// Build request
	req := &loomv1.ApplyImprovementRequest{
		ImprovementId: improvementID,
	}

	// Apply improvement
	fmt.Printf("ðŸš€ Applying improvement %s...\n", improvementID)

	resp, err := client.ApplyImprovement(ctx, req)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error applying improvement: %v\n", err)
		os.Exit(1)
	}

	// Display result
	improvement := resp.Improvement
	fmt.Printf("\nâœ… Improvement applied successfully!\n\n")
	fmt.Printf("   ID: %s\n", improvement.Id)
	fmt.Printf("   Pattern: %s\n", improvement.TargetPattern)
	fmt.Printf("   Domain: %s | Agent: %s\n", improvement.Domain, improvement.TargetAgentId)
	fmt.Printf("   Status: %s\n", improvement.Status.String())
	fmt.Printf("   Applied at: %s\n", time.UnixMilli(improvement.AppliedAt).Format(time.RFC3339))

	fmt.Printf("\nðŸ’¡ Pattern hot-reloaded. Changes are now active.\n")
	fmt.Printf("   To rollback: looms learning rollback %s\n", improvement.Id)
}

func runLearningRollback(cmd *cobra.Command, args []string) {
	improvementID := args[0]

	// Create client
	client, conn, err := createLearningClient(learningServer)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error connecting to server: %v\n", err)
		os.Exit(1)
	}
	defer conn.Close()

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), time.Duration(learningTimeout)*time.Second)
	defer cancel()

	// Build request
	req := &loomv1.RollbackImprovementRequest{
		ImprovementId: improvementID,
	}

	// Rollback improvement
	fmt.Printf("âª Rolling back improvement %s...\n", improvementID)

	resp, err := client.RollbackImprovement(ctx, req)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error rolling back improvement: %v\n", err)
		os.Exit(1)
	}

	// Display result
	fmt.Printf("\nâœ… Improvement rolled back successfully!\n\n")
	fmt.Printf("   ID: %s\n", improvementID)
	if resp.Success {
		fmt.Printf("   Message: %s\n", resp.Message)
	}
	if resp.RestoredVersion != "" {
		fmt.Printf("   Restored version: %s\n", resp.RestoredVersion)
	}
	if resp.RollbackCompletedAt > 0 {
		fmt.Printf("   Rolled back at: %s\n", time.UnixMilli(resp.RollbackCompletedAt).Format(time.RFC3339))
	}

	fmt.Printf("\nðŸ’¡ Pattern hot-reloaded. Previous version restored.\n")
}

func runLearningHistory(cmd *cobra.Command, args []string) {
	// Create client
	client, conn, err := createLearningClient(learningServer)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error connecting to server: %v\n", err)
		os.Exit(1)
	}
	defer conn.Close()

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), time.Duration(learningTimeout)*time.Second)
	defer cancel()

	// Parse status filter
	var statusFilter loomv1.ImprovementStatus
	if learningStatus != "" {
		switch strings.ToLower(learningStatus) {
		case "pending":
			statusFilter = loomv1.ImprovementStatus_IMPROVEMENT_PENDING
		case "applied":
			statusFilter = loomv1.ImprovementStatus_IMPROVEMENT_APPLIED
		case "rolled_back", "rollback":
			statusFilter = loomv1.ImprovementStatus_IMPROVEMENT_ROLLED_BACK
		case "rejected":
			statusFilter = loomv1.ImprovementStatus_IMPROVEMENT_REJECTED
		}
	}

	// Build request
	req := &loomv1.GetImprovementHistoryRequest{
		Domain:  learningDomain,
		AgentId: learningAgent,
		Status:  statusFilter,
		Limit:   learningLimit,
		Offset:  0,
	}

	// Get history
	fmt.Printf("ðŸ“œ Improvement History\n")
	if learningDomain != "" {
		fmt.Printf("   Domain: %s\n", learningDomain)
	}
	if learningAgent != "" {
		fmt.Printf("   Agent: %s\n", learningAgent)
	}
	if learningStatus != "" {
		fmt.Printf("   Status: %s\n", learningStatus)
	}
	fmt.Printf("   Limit: %d\n\n", learningLimit)

	resp, err := client.GetImprovementHistory(ctx, req)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error getting history: %v\n", err)
		os.Exit(1)
	}

	if len(resp.Improvements) == 0 {
		fmt.Println("No improvement history found.")
		return
	}

	// Display history
	fmt.Printf("ðŸ“Š History (%d entries)\n", len(resp.Improvements))
	fmt.Println(strings.Repeat("â”€", 80))

	for i, improvement := range resp.Improvements {
		var statusIcon string
		switch improvement.Status {
		case loomv1.ImprovementStatus_IMPROVEMENT_PENDING:
			statusIcon = "â¸ï¸ "
		case loomv1.ImprovementStatus_IMPROVEMENT_APPLIED:
			statusIcon = "âœ…"
		case loomv1.ImprovementStatus_IMPROVEMENT_ROLLED_BACK:
			statusIcon = "âª"
		case loomv1.ImprovementStatus_IMPROVEMENT_REJECTED:
			statusIcon = "âŒ"
		}

		fmt.Printf("\n[%d] %s %s\n", i+1, statusIcon, improvement.Id)
		fmt.Printf("    Pattern: %s\n", improvement.TargetPattern)
		fmt.Printf("    Domain: %s | Agent: %s\n", improvement.Domain, improvement.TargetAgentId)
		fmt.Printf("    Status: %s\n", improvement.Status.String())
		fmt.Printf("    Created: %s\n", time.UnixMilli(improvement.CreatedAt).Format(time.RFC3339))

		if improvement.AppliedAt > 0 {
			fmt.Printf("    Applied: %s\n", time.UnixMilli(improvement.AppliedAt).Format(time.RFC3339))
		}

		// Expected benefits (from details)
		if improvement.Details != nil && improvement.Status == loomv1.ImprovementStatus_IMPROVEMENT_APPLIED {
			fmt.Printf("    Expected Impact:\n")
			fmt.Printf("      Success Rate: %+.1f%% | Cost: $%.4f | Latency: %+dms\n",
				improvement.Details.ExpectedSuccessRateDelta*100,
				improvement.Details.ExpectedCostDeltaUsd,
				improvement.Details.ExpectedLatencyDeltaMs)
		}
	}

	fmt.Println(strings.Repeat("â”€", 80))
	fmt.Printf("\nâœ… Showing %d of %d total improvements.\n", len(resp.Improvements), resp.TotalCount)
}

func runLearningStream(cmd *cobra.Command, args []string) {
	// Create client
	client, conn, err := createLearningClient(learningServer)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error connecting to server: %v\n", err)
		os.Exit(1)
	}
	defer conn.Close()

	// Build request
	req := &loomv1.StreamPatternMetricsRequest{
		Domain:  learningDomain,
		AgentId: learningAgent,
	}

	// Print header
	fmt.Printf("ðŸ“¡ Streaming pattern metrics from %s\n", learningServer)
	if learningDomain != "" {
		fmt.Printf("   Filter: domain=%s\n", learningDomain)
	}
	if learningAgent != "" {
		fmt.Printf("   Filter: agent=%s\n", learningAgent)
	}
	fmt.Println("\nPress Ctrl+C to stop streaming")
	fmt.Println(strings.Repeat("â”€", 80))

	// Create context that can be cancelled with Ctrl+C
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	// Handle Ctrl+C
	go func() {
		sigCh := make(chan os.Signal, 1)
		signal.Notify(sigCh, os.Interrupt)
		<-sigCh
		fmt.Println("\n\nStopping stream...")
		cancel()
	}()

	// Stream pattern metrics
	stream, err := client.StreamPatternMetrics(ctx, req)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error starting stream: %v\n", err)
		os.Exit(1)
	}

	// Receive and display metrics
	for {
		event, err := stream.Recv()
		if err != nil {
			if err.Error() == "EOF" || err.Error() == "context canceled" {
				break
			}
			fmt.Fprintf(os.Stderr, "\nError receiving metric: %v\n", err)
			break
		}

		metric := event.Metric
		timestamp := time.UnixMilli(event.Timestamp).Format("15:04:05")

		// Display metric
		fmt.Printf("[%s] ðŸ“Š %s (variant: %s)\n",
			timestamp, metric.PatternName, metric.Variant)
		fmt.Printf("         Domain: %s | Usage: %d | Success: %.1f%%\n",
			metric.Domain, metric.TotalUsages, metric.SuccessRate*100)
		fmt.Printf("         Cost: $%.4f | Latency: %dms\n",
			metric.AvgCostUsd, metric.AvgLatencyMs)

		if len(metric.ErrorTypes) > 0 {
			errorStrs := []string{}
			for errorType, count := range metric.ErrorTypes {
				errorStrs = append(errorStrs, fmt.Sprintf("%s(%d)", errorType, count))
			}
			fmt.Printf("         Errors: %s\n", strings.Join(errorStrs, ", "))
		}
		fmt.Println()
	}

	fmt.Println(strings.Repeat("â”€", 80))
	fmt.Println("Stream stopped.")
}

func runLearningTune(cmd *cobra.Command, args []string) {
	// Create client
	client, conn, err := createLearningClient(learningServer)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error connecting to server: %v\n", err)
		os.Exit(1)
	}
	defer conn.Close()

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), time.Duration(learningTimeout)*time.Second)
	defer cancel()

	// Parse tuning strategy
	var strategy loomv1.TuningStrategy
	switch strings.ToLower(learningTuneStrategy) {
	case "conservative":
		strategy = loomv1.TuningStrategy_TUNING_CONSERVATIVE
	case "moderate":
		strategy = loomv1.TuningStrategy_TUNING_MODERATE
	case "aggressive":
		strategy = loomv1.TuningStrategy_TUNING_AGGRESSIVE
	default:
		fmt.Fprintf(os.Stderr, "Invalid strategy '%s'. Use: conservative, moderate, or aggressive\n", learningTuneStrategy)
		os.Exit(1)
	}

	// Build dimension weights map (if any dimension flags are set)
	var dimensionWeights map[string]float64
	dimensionSum := learningTuneDimQuality + learningTuneDimSafety + learningTuneDimCost +
		learningTuneDimDomain + learningTuneDimPerf + learningTuneDimUsability

	useDimensionWeights := dimensionSum > 0

	if useDimensionWeights {
		// Using judge dimension weights
		dimensionWeights = make(map[string]float64)
		if learningTuneDimQuality > 0 {
			dimensionWeights["quality"] = learningTuneDimQuality
		}
		if learningTuneDimSafety > 0 {
			dimensionWeights["safety"] = learningTuneDimSafety
		}
		if learningTuneDimCost > 0 {
			dimensionWeights["cost"] = learningTuneDimCost
		}
		if learningTuneDimDomain > 0 {
			dimensionWeights["domain"] = learningTuneDimDomain
		}
		if learningTuneDimPerf > 0 {
			dimensionWeights["performance"] = learningTuneDimPerf
		}
		if learningTuneDimUsability > 0 {
			dimensionWeights["usability"] = learningTuneDimUsability
		}

		// Validate and normalize dimension weights
		if dimensionSum < 0.99 || dimensionSum > 1.01 {
			fmt.Fprintf(os.Stderr, "Warning: Dimension weights sum to %.2f (expected 1.0)\n", dimensionSum)
			fmt.Fprintf(os.Stderr, "         Normalizing weights...\n")
			for dim := range dimensionWeights {
				dimensionWeights[dim] /= dimensionSum
			}
		}
	} else {
		// Using legacy weights - set defaults if not specified
		legacySum := learningTuneCostWeight + learningTuneQualWeight + learningTuneLatWeight

		if legacySum == 0 {
			// No weights specified - use defaults
			learningTuneQualWeight = 0.5
			learningTuneCostWeight = 0.3
			learningTuneLatWeight = 0.2
		} else if legacySum < 0.99 || legacySum > 1.01 {
			// Normalize if needed
			fmt.Fprintf(os.Stderr, "Warning: Legacy weights sum to %.2f (expected 1.0)\n", legacySum)
			fmt.Fprintf(os.Stderr, "         Normalizing weights...\n")
			learningTuneCostWeight /= legacySum
			learningTuneQualWeight /= legacySum
			learningTuneLatWeight /= legacySum
		}
	}

	// Build request
	req := &loomv1.TunePatternsRequest{
		Domain:  learningDomain,
		AgentId: learningAgent,
		OptimizationGoal: &loomv1.OptimizationGoal{
			CostWeight:       learningTuneCostWeight,
			QualityWeight:    learningTuneQualWeight,
			LatencyWeight:    learningTuneLatWeight,
			DimensionWeights: dimensionWeights,
		},
		Strategy:           strategy,
		DryRun:             learningTuneDryRun,
		PatternLibraryPath: learningTuneLibrary,
	}

	// Print configuration
	fmt.Printf("ðŸŽ¯ Pattern Tuning Configuration\n")
	fmt.Println(strings.Repeat("â”€", 80))
	if learningDomain != "" {
		fmt.Printf("   Domain: %s\n", learningDomain)
	}
	if learningAgent != "" {
		fmt.Printf("   Agent: %s\n", learningAgent)
	}
	fmt.Printf("   Strategy: %s\n", learningTuneStrategy)
	fmt.Printf("   Library: %s\n", learningTuneLibrary)
	fmt.Printf("   Mode: ")
	if learningTuneDryRun {
		fmt.Printf("DRY RUN (preview only)\n")
	} else {
		fmt.Printf("APPLY CHANGES\n")
	}

	// Display weights based on mode
	if useDimensionWeights {
		fmt.Printf("\n   âœ… Using Judge Dimension Weights:\n")
		if dimensionWeights["quality"] > 0 {
			fmt.Printf("   - Quality:     %.1f%%\n", dimensionWeights["quality"]*100)
		}
		if dimensionWeights["safety"] > 0 {
			fmt.Printf("   - Safety:      %.1f%%\n", dimensionWeights["safety"]*100)
		}
		if dimensionWeights["cost"] > 0 {
			fmt.Printf("   - Cost:        %.1f%%\n", dimensionWeights["cost"]*100)
		}
		if dimensionWeights["domain"] > 0 {
			fmt.Printf("   - Domain:      %.1f%%\n", dimensionWeights["domain"]*100)
		}
		if dimensionWeights["performance"] > 0 {
			fmt.Printf("   - Performance: %.1f%%\n", dimensionWeights["performance"]*100)
		}
		if dimensionWeights["usability"] > 0 {
			fmt.Printf("   - Usability:   %.1f%%\n", dimensionWeights["usability"]*100)
		}
		fmt.Printf("\n   ðŸ’¡ Patterns with judge scores will use dimension-weighted scoring\n")
		fmt.Printf("      Patterns without judge scores will fall back to legacy weights\n")
	} else {
		fmt.Printf("\n   âš ï¸  Using Legacy Weights (consider using --dimension-* flags):\n")
		fmt.Printf("   - Quality: %.1f%%\n", learningTuneQualWeight*100)
		fmt.Printf("   - Cost:    %.1f%%\n", learningTuneCostWeight*100)
		fmt.Printf("   - Latency: %.1f%%\n", learningTuneLatWeight*100)
		fmt.Printf("\n   ðŸ’¡ Tip: Use --dimension-quality, --dimension-safety, etc. for judge-based tuning\n")
	}

	fmt.Println(strings.Repeat("â”€", 80))
	fmt.Printf("\nðŸ” Analyzing patterns and calculating tunings...\n\n")

	// Call tune patterns
	resp, err := client.TunePatterns(ctx, req)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error tuning patterns: %v\n", err)
		os.Exit(1)
	}

	// Display results
	if len(resp.Tunings) == 0 {
		fmt.Println("No patterns found to tune. Run agents with patterns to collect metrics.")
		return
	}

	fmt.Printf("ðŸ“Š Pattern Tuning Results (%d patterns analyzed)\n", resp.Summary.PatternsAnalyzed)
	fmt.Println(strings.Repeat("â”€", 80))

	for _, tuning := range resp.Tunings {
		// Pattern header
		fmt.Printf("\nðŸŽ¯ %s (domain: %s)\n", tuning.PatternName, tuning.Domain)

		// Confidence indicator
		var confidenceIcon string
		switch tuning.Confidence {
		case loomv1.TuningConfidence_TUNING_LOW:
			confidenceIcon = "âš ï¸  LOW"
		case loomv1.TuningConfidence_TUNING_MEDIUM:
			confidenceIcon = "âš¡ MEDIUM"
		case loomv1.TuningConfidence_TUNING_HIGH:
			confidenceIcon = "âœ… HIGH"
		default:
			confidenceIcon = "â“ UNKNOWN"
		}
		fmt.Printf("   Confidence: %s\n", confidenceIcon)

		// Display adjustments
		if len(tuning.Adjustments) > 0 {
			fmt.Printf("   Adjustments:\n")
			for _, adj := range tuning.Adjustments {
				fmt.Printf("      %s: %s â†’ %s (%s)\n",
					adj.ParameterName, adj.OldValue, adj.NewValue, adj.Reason)
			}
		}

		// Before/after metrics
		if tuning.BeforeMetrics != nil {
			fmt.Printf("   Before: Success: %.1f%% | Cost: $%.4f | Latency: %dms\n",
				tuning.BeforeMetrics.SuccessRate*100,
				tuning.BeforeMetrics.AvgCostUsd,
				tuning.BeforeMetrics.AvgLatencyMs)
		}
		if tuning.ProjectedMetrics != nil {
			fmt.Printf("   After:  Success: %.1f%% | Cost: $%.4f | Latency: %dms\n",
				tuning.ProjectedMetrics.SuccessRate*100,
				tuning.ProjectedMetrics.AvgCostUsd,
				tuning.ProjectedMetrics.AvgLatencyMs)
		}

		// Rationale
		if tuning.Rationale != "" {
			fmt.Printf("   Rationale: %s\n", tuning.Rationale)
		}
	}

	fmt.Println(strings.Repeat("â”€", 80))

	// Summary
	summary := resp.Summary
	fmt.Printf("\nâœ… Tuning Summary\n")
	fmt.Printf("   Patterns Analyzed: %d\n", summary.PatternsAnalyzed)
	fmt.Printf("   Patterns Tuned: %d\n", summary.PatternsTuned)
	fmt.Printf("   - Promoted (â†‘): %d\n", summary.PatternsPromoted)
	fmt.Printf("   - Demoted (â†“):  %d\n", summary.PatternsDemoted)
	fmt.Printf("   - Unchanged:    %d\n", summary.PatternsUnchanged)
	fmt.Printf("\n   Estimated Impact:\n")
	if summary.EstimatedSuccessRateImprovement != 0 {
		fmt.Printf("   - Success Rate: %+.1f%%\n", summary.EstimatedSuccessRateImprovement*100)
	}
	if summary.EstimatedCostReductionUsd != 0 {
		fmt.Printf("   - Cost:         $%.4f\n", summary.EstimatedCostReductionUsd)
	}
	if summary.EstimatedLatencyReductionMs != 0 {
		fmt.Printf("   - Latency:      %+dms\n", summary.EstimatedLatencyReductionMs)
	}

	fmt.Println()
	if learningTuneDryRun {
		fmt.Println("ðŸ’¡ This was a dry run. To apply changes, run without --dry-run flag.")
	} else {
		fmt.Println("âœ… Pattern tuning applied! Changes are now active.")
		fmt.Println("   Monitor with: looms learning stream")
	}
}

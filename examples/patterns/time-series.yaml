# Time Series Analysis Patterns
#
# Patterns for analyzing temporal data, detecting trends, forecasting,
# and working with time-based aggregations.

apiVersion: loom/v1
kind: PatternLibrary

metadata:
  name: time-series-patterns
  description: Time series analysis and forecasting patterns
  version: "1.0"
  tags:
    - time-series
    - temporal
    - forecasting
    - trends

patterns:
  # Time-based Aggregation
  - name: time_aggregation
    description: Aggregate data over time intervals
    intent_keywords:
      - aggregate by time
      - time series
      - temporal aggregation
      - time buckets

    template: |
      Aggregate metrics over time intervals.

      Steps:
      1. Determine time interval (hour, day, week, month)
      2. Use DATE_TRUNC or DATE_BUCKET
      3. Apply aggregation functions (SUM, AVG, COUNT)
      4. Fill gaps with default values if needed
      5. Order by time ascending

    examples:
      - input: "Aggregate sales by day"
        output: |
          SELECT
            DATE_TRUNC('day', order_date) as day,
            COUNT(*) as order_count,
            SUM(total_amount) as daily_revenue,
            AVG(total_amount) as avg_order_value
          FROM orders
          WHERE order_date >= CURRENT_DATE - INTERVAL '30 days'
          GROUP BY DATE_TRUNC('day', order_date)
          ORDER BY day

      - input: "Get hourly active users"
        output: |
          SELECT
            DATE_TRUNC('hour', activity_timestamp) as hour,
            COUNT(DISTINCT user_id) as active_users,
            COUNT(*) as total_events
          FROM user_activity
          WHERE activity_timestamp >= CURRENT_TIMESTAMP - INTERVAL '24 hours'
          GROUP BY DATE_TRUNC('hour', activity_timestamp)
          ORDER BY hour

  # Moving Averages
  - name: moving_average
    description: Calculate moving averages to smooth trends
    intent_keywords:
      - moving average
      - rolling average
      - smoothed trend
      - ma calculation

    template: |
      Calculate moving averages over time windows.

      Steps:
      1. Order data by time
      2. Use window functions with ROWS BETWEEN
      3. Calculate average over N preceding rows
      4. Handle edge cases at start of series
      5. Support different window sizes (7-day, 30-day, etc.)

    examples:
      - input: "Calculate 7-day moving average of sales"
        output: |
          SELECT
            date,
            daily_sales,
            AVG(daily_sales) OVER (
              ORDER BY date
              ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
            ) as ma_7day,
            AVG(daily_sales) OVER (
              ORDER BY date
              ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
            ) as ma_30day
          FROM daily_metrics
          ORDER BY date

      - input: "Get smoothed active user trend"
        output: |
          SELECT
            date,
            active_users,
            AVG(active_users) OVER (
              ORDER BY date
              ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
            ) as ma_7day,
            active_users - AVG(active_users) OVER (
              ORDER BY date
              ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
            ) as deviation_from_ma
          FROM daily_active_users
          ORDER BY date

  # Growth Rate Calculation
  - name: growth_rate
    description: Calculate period-over-period growth rates
    intent_keywords:
      - growth rate
      - period over period
      - yoy growth
      - mom growth

    template: |
      Calculate growth metrics compared to previous periods.

      Steps:
      1. Identify comparison period (day, week, month, year)
      2. Use LAG() to get previous period value
      3. Calculate absolute growth
      4. Calculate percentage growth
      5. Handle null/zero previous values

    examples:
      - input: "Calculate month-over-month revenue growth"
        output: |
          WITH monthly_revenue AS (
            SELECT
              DATE_TRUNC('month', order_date) as month,
              SUM(total_amount) as revenue
            FROM orders
            GROUP BY DATE_TRUNC('month', order_date)
          )
          SELECT
            month,
            revenue,
            LAG(revenue) OVER (ORDER BY month) as prev_month_revenue,
            revenue - LAG(revenue) OVER (ORDER BY month) as absolute_growth,
            (revenue - LAG(revenue) OVER (ORDER BY month)) * 100.0 /
              NULLIF(LAG(revenue) OVER (ORDER BY month), 0) as growth_rate_pct
          FROM monthly_revenue
          ORDER BY month

      - input: "Get year-over-year user growth"
        output: |
          WITH yearly_users AS (
            SELECT
              EXTRACT(YEAR FROM signup_date) as year,
              COUNT(*) as new_users
            FROM users
            GROUP BY EXTRACT(YEAR FROM signup_date)
          )
          SELECT
            year,
            new_users,
            LAG(new_users, 1) OVER (ORDER BY year) as prev_year_users,
            (new_users - LAG(new_users, 1) OVER (ORDER BY year)) * 100.0 /
              LAG(new_users, 1) OVER (ORDER BY year) as yoy_growth_pct
          FROM yearly_users
          ORDER BY year

  # Trend Detection
  - name: trend_detection
    description: Detect trends using linear regression or moving averages
    intent_keywords:
      - detect trend
      - trend analysis
      - upward trend
      - downward trend

    template: |
      Identify trends in time series data.

      Steps:
      1. Calculate moving average for smoothing
      2. Compare recent periods to historical baseline
      3. Detect direction (up, down, flat)
      4. Calculate trend strength
      5. Identify trend reversals

    examples:
      - input: "Detect revenue trend"
        output: |
          WITH daily_metrics AS (
            SELECT
              DATE_TRUNC('day', order_date) as day,
              SUM(total_amount) as daily_revenue
            FROM orders
            WHERE order_date >= CURRENT_DATE - INTERVAL '90 days'
            GROUP BY DATE_TRUNC('day', order_date)
          ),
          with_ma AS (
            SELECT
              day,
              daily_revenue,
              AVG(daily_revenue) OVER (
                ORDER BY day
                ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
              ) as ma_7day,
              AVG(daily_revenue) OVER (
                ORDER BY day
                ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
              ) as ma_30day
            FROM daily_metrics
          )
          SELECT
            day,
            daily_revenue,
            ma_7day,
            ma_30day,
            CASE
              WHEN ma_7day > ma_30day * 1.05 THEN 'upward'
              WHEN ma_7day < ma_30day * 0.95 THEN 'downward'
              ELSE 'flat'
            END as trend
          FROM with_ma
          WHERE day >= CURRENT_DATE - INTERVAL '30 days'
          ORDER BY day

  # Seasonality Analysis
  - name: seasonality_analysis
    description: Analyze seasonal patterns in data
    intent_keywords:
      - seasonality
      - seasonal pattern
      - cyclical pattern
      - seasonal decomposition

    template: |
      Identify seasonal patterns (daily, weekly, monthly, yearly).

      Steps:
      1. Extract time components (hour, day of week, month)
      2. Group by time component
      3. Calculate average for each period
      4. Compare to overall average
      5. Identify seasonal peaks and troughs

    examples:
      - input: "Analyze weekly seasonality of orders"
        output: |
          SELECT
            EXTRACT(DOW FROM order_date) as day_of_week,
            CASE EXTRACT(DOW FROM order_date)
              WHEN 0 THEN 'Sunday'
              WHEN 1 THEN 'Monday'
              WHEN 2 THEN 'Tuesday'
              WHEN 3 THEN 'Wednesday'
              WHEN 4 THEN 'Thursday'
              WHEN 5 THEN 'Friday'
              WHEN 6 THEN 'Saturday'
            END as day_name,
            COUNT(*) as total_orders,
            AVG(total_amount) as avg_order_value,
            SUM(total_amount) as total_revenue
          FROM orders
          WHERE order_date >= CURRENT_DATE - INTERVAL '90 days'
          GROUP BY EXTRACT(DOW FROM order_date)
          ORDER BY day_of_week

      - input: "Find monthly seasonal pattern"
        output: |
          WITH monthly_sales AS (
            SELECT
              EXTRACT(MONTH FROM order_date) as month,
              EXTRACT(YEAR FROM order_date) as year,
              SUM(total_amount) as monthly_revenue
            FROM orders
            GROUP BY EXTRACT(YEAR FROM order_date), EXTRACT(MONTH FROM order_date)
          )
          SELECT
            month,
            AVG(monthly_revenue) as avg_revenue,
            STDDEV(monthly_revenue) as stddev_revenue,
            MIN(monthly_revenue) as min_revenue,
            MAX(monthly_revenue) as max_revenue
          FROM monthly_sales
          GROUP BY month
          ORDER BY month

  # Gap Filling
  - name: gap_filling
    description: Fill missing time periods with default or interpolated values
    intent_keywords:
      - fill gaps
      - missing periods
      - interpolate
      - complete time series

    template: |
      Generate continuous time series with filled gaps.

      Steps:
      1. Generate complete time range with GENERATE_SERIES
      2. Left join actual data
      3. Fill nulls with:
        - Zero for counts
        - Previous value (forward fill)
        - Average of neighbors (interpolation)
      4. Handle edge cases

    examples:
      - input: "Fill missing days in sales data"
        output: |
          WITH date_range AS (
            SELECT generate_series(
              CURRENT_DATE - INTERVAL '30 days',
              CURRENT_DATE,
              '1 day'::interval
            )::date as date
          ),
          daily_sales AS (
            SELECT
              DATE_TRUNC('day', order_date)::date as date,
              SUM(total_amount) as revenue
            FROM orders
            GROUP BY DATE_TRUNC('day', order_date)::date
          )
          SELECT
            dr.date,
            COALESCE(ds.revenue, 0) as revenue
          FROM date_range dr
          LEFT JOIN daily_sales ds ON dr.date = ds.date
          ORDER BY dr.date

      - input: "Interpolate missing hourly metrics"
        output: |
          WITH hours AS (
            SELECT generate_series(
              DATE_TRUNC('day', CURRENT_TIMESTAMP - INTERVAL '7 days'),
              CURRENT_TIMESTAMP,
              '1 hour'::interval
            ) as hour
          ),
          metrics AS (
            SELECT
              DATE_TRUNC('hour', timestamp) as hour,
              AVG(value) as avg_value
            FROM sensor_data
            GROUP BY DATE_TRUNC('hour', timestamp)
          )
          SELECT
            h.hour,
            COALESCE(
              m.avg_value,
              LAG(m.avg_value) OVER (ORDER BY h.hour),
              0
            ) as value
          FROM hours h
          LEFT JOIN metrics m ON h.hour = m.hour
          ORDER BY h.hour

  # Cumulative Metrics
  - name: cumulative_aggregation
    description: Calculate running totals and cumulative metrics
    intent_keywords:
      - cumulative sum
      - running total
      - cumulative count
      - ytd total

    template: |
      Calculate cumulative metrics over time.

      Steps:
      1. Order data by time
      2. Use SUM() OVER with unbounded preceding
      3. Partition by period if needed (yearly, monthly)
      4. Calculate cumulative percentages
      5. Handle resets for new periods

    examples:
      - input: "Calculate year-to-date revenue"
        output: |
          SELECT
            order_date,
            daily_revenue,
            SUM(daily_revenue) OVER (
              PARTITION BY EXTRACT(YEAR FROM order_date)
              ORDER BY order_date
              ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
            ) as ytd_revenue
          FROM (
            SELECT
              DATE_TRUNC('day', order_date)::date as order_date,
              SUM(total_amount) as daily_revenue
            FROM orders
            GROUP BY DATE_TRUNC('day', order_date)::date
          ) daily
          ORDER BY order_date

      - input: "Get cumulative user signups"
        output: |
          WITH daily_signups AS (
            SELECT
              DATE_TRUNC('day', signup_date)::date as date,
              COUNT(*) as new_users
            FROM users
            GROUP BY DATE_TRUNC('day', signup_date)::date
          )
          SELECT
            date,
            new_users,
            SUM(new_users) OVER (
              ORDER BY date
              ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
            ) as cumulative_users
          FROM daily_signups
          ORDER BY date

# REST API Patterns
#
# Patterns for interacting with REST APIs, handling authentication,
# pagination, error handling, and data transformation.

apiVersion: loom/v1
kind: PatternLibrary

metadata:
  name: rest-api-patterns
  description: Common patterns for REST API interactions
  version: "1.0"
  tags:
    - rest
    - api
    - http
    - integration

patterns:
  # CRUD Operations
  - name: rest_crud_operations
    description: Standard Create, Read, Update, Delete operations
    intent_keywords:
      - create resource
      - get data
      - update record
      - delete item
      - fetch resource

    template: |
      Execute CRUD operations on REST API endpoints.

      Steps:
      1. Identify the resource type and endpoint
      2. Determine HTTP method (GET, POST, PUT, PATCH, DELETE)
      3. Prepare request body (JSON) for POST/PUT/PATCH
      4. Add authentication headers
      5. Make request and handle response
      6. Transform response data to desired format

    examples:
      - input: "Get user by ID"
        output: |
          GET /api/v1/users/12345
          Headers:
            Authorization: Bearer {token}
            Accept: application/json

      - input: "Create new order"
        output: |
          POST /api/v1/orders
          Headers:
            Authorization: Bearer {token}
            Content-Type: application/json
          Body:
            {
              "customer_id": "cust_123",
              "items": [
                {"product_id": "prod_456", "quantity": 2}
              ],
              "shipping_address": "123 Main St"
            }

      - input: "Update product price"
        output: |
          PATCH /api/v1/products/789
          Headers:
            Authorization: Bearer {token}
            Content-Type: application/json
          Body:
            {
              "price": 29.99
            }

  # Pagination Handling
  - name: rest_pagination
    description: Handle paginated API responses
    intent_keywords:
      - fetch all
      - paginate through
      - get all records
      - iterate pages

    template: |
      Retrieve all data from paginated endpoints.

      Steps:
      1. Detect pagination style (offset, cursor, page-based)
      2. Make initial request
      3. Extract pagination metadata (next page URL, cursor, total pages)
      4. Loop through pages until exhausted
      5. Aggregate results
      6. Handle rate limiting between requests

    examples:
      - input: "Get all customers with pagination"
        output: |
          # Offset-based pagination
          Page 1: GET /api/v1/customers?limit=100&offset=0
          Page 2: GET /api/v1/customers?limit=100&offset=100
          Continue until response is empty or count < limit

      - input: "Fetch all orders using cursor"
        output: |
          # Cursor-based pagination
          Page 1: GET /api/v1/orders?limit=100
          Extract: next_cursor from response
          Page 2: GET /api/v1/orders?limit=100&cursor={next_cursor}
          Continue until next_cursor is null

  # Filtering and Search
  - name: rest_filtering
    description: Apply filters and search criteria to API queries
    intent_keywords:
      - filter by
      - search for
      - find where
      - query with conditions

    template: |
      Construct filtered API requests.

      Steps:
      1. Identify filterable fields
      2. Translate conditions to query parameters
      3. Combine multiple filters
      4. Handle date ranges and numeric comparisons
      5. Apply sorting if needed
      6. Make request with query string

    examples:
      - input: "Find active users created last month"
        output: |
          GET /api/v1/users?status=active&created_after=2025-01-01&created_before=2025-01-31&sort=created_at&order=desc

      - input: "Search products by category and price range"
        output: |
          GET /api/v1/products?category=electronics&price_min=100&price_max=500&in_stock=true

  # Batch Operations
  - name: rest_batch_operations
    description: Batch multiple operations in single request
    intent_keywords:
      - batch create
      - bulk update
      - batch delete
      - bulk operation

    template: |
      Execute operations in batches for efficiency.

      Steps:
      1. Check if API supports batch endpoint
      2. Group operations into batches (respect API limits)
      3. Format batch request (array of operations or multipart)
      4. Execute batch request
      5. Handle partial failures
      6. Retry failed items individually if needed

    examples:
      - input: "Create multiple users at once"
        output: |
          POST /api/v1/users/batch
          Body:
            {
              "users": [
                {"name": "Alice", "email": "alice@example.com"},
                {"name": "Bob", "email": "bob@example.com"}
              ]
            }

      - input: "Bulk update order status"
        output: |
          PATCH /api/v1/orders/batch
          Body:
            {
              "operations": [
                {"order_id": "123", "status": "shipped"},
                {"order_id": "456", "status": "shipped"}
              ]
            }

  # Rate Limiting
  - name: rest_rate_limiting
    description: Handle API rate limits gracefully
    intent_keywords:
      - rate limit
      - throttle requests
      - respect limits
      - backoff

    template: |
      Manage rate limits and implement backoff strategies.

      Steps:
      1. Check response headers for rate limit info
        - X-RateLimit-Limit: total allowed
        - X-RateLimit-Remaining: requests left
        - X-RateLimit-Reset: reset timestamp
      2. Track request count
      3. Implement exponential backoff on 429 responses
      4. Add delays between requests if needed
      5. Queue requests to stay within limits

    examples:
      - input: "Make API calls with rate limiting"
        output: |
          Check headers after each request:
          X-RateLimit-Remaining: 45

          If 429 Too Many Requests received:
          - Wait for Retry-After seconds (from header)
          - Or implement exponential backoff: 1s, 2s, 4s, 8s

          If X-RateLimit-Remaining < 5:
          - Add delay: (reset_time - current_time) / remaining_requests

  # Error Handling
  - name: rest_error_handling
    description: Handle API errors and implement retry logic
    intent_keywords:
      - handle errors
      - retry failed
      - error recovery
      - fault tolerance

    template: |
      Implement robust error handling for API calls.

      Steps:
      1. Classify errors by status code:
        - 400-499: Client errors (don't retry)
        - 500-599: Server errors (retry with backoff)
        - Network errors: retry with backoff
      2. Parse error response for details
      3. Log error context
      4. Implement retry strategy for transient errors
      5. Provide fallback or graceful degradation

    examples:
      - input: "Handle API errors with retry"
        output: |
          Status 400 Bad Request:
          - Parse error: {"error": "invalid_email", "message": "Email format is invalid"}
          - Don't retry, return error to user

          Status 429 Too Many Requests:
          - Wait for Retry-After: 60 seconds
          - Retry request

          Status 500 Internal Server Error:
          - Retry with exponential backoff: 1s, 2s, 4s
          - Max retries: 3
          - If all retries fail, return error

          Status 503 Service Unavailable:
          - Retry after 5 seconds
          - Use circuit breaker pattern

  # Authentication Patterns
  - name: rest_authentication
    description: Handle various authentication methods
    intent_keywords:
      - authenticate
      - get token
      - refresh token
      - login

    template: |
      Manage authentication for API access.

      Steps:
      1. Identify auth method (Bearer token, API key, OAuth2, Basic Auth)
      2. Obtain credentials/token
      3. Add auth header to requests
      4. Handle token expiration
      5. Refresh token if needed
      6. Store token securely

    examples:
      - input: "OAuth2 authentication flow"
        output: |
          1. Get access token:
             POST /oauth/token
             Body: {
               "grant_type": "client_credentials",
               "client_id": "{client_id}",
               "client_secret": "{client_secret}"
             }
             Response: {"access_token": "...", "expires_in": 3600}

          2. Use token in requests:
             GET /api/v1/users
             Authorization: Bearer {access_token}

          3. Refresh when expired:
             POST /oauth/token
             Body: {
               "grant_type": "refresh_token",
               "refresh_token": "{refresh_token}"
             }

      - input: "API key authentication"
        output: |
          GET /api/v1/data
          Headers:
            X-API-Key: {api_key}
            # Or
            Authorization: ApiKey {api_key}

  # Webhook Handling
  - name: rest_webhooks
    description: Register and handle webhook events
    intent_keywords:
      - setup webhook
      - webhook callback
      - event notification
      - subscribe to events

    template: |
      Configure webhooks for event-driven updates.

      Steps:
      1. Register webhook endpoint
        POST /api/v1/webhooks
        Body: {
          "url": "https://myapp.com/webhooks/api-events",
          "events": ["order.created", "order.updated"]
        }
      2. Implement webhook receiver endpoint
      3. Verify webhook signatures
      4. Handle event payload
      5. Respond with 200 OK quickly
      6. Process event asynchronously

    examples:
      - input: "Register webhook for order events"
        output: |
          POST /api/v1/webhooks
          Body:
            {
              "url": "https://myapp.com/webhooks/orders",
              "events": ["order.created", "order.shipped", "order.delivered"],
              "secret": "webhook_secret_key"
            }

          Webhook payload received:
            {
              "event": "order.created",
              "data": {
                "order_id": "123",
                "customer_id": "456",
                "total": 99.99
              },
              "timestamp": "2025-11-19T10:00:00Z",
              "signature": "sha256=..."
            }

          Verify signature:
            HMAC-SHA256(payload, webhook_secret) == signature
